/*! For license information please see index.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={64:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInteger = void 0;\nconst isInteger = (value) => {\n    return typeof value === 'number' && Number.isInteger(value);\n};\nexports.isInteger = isInteger;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isInteger.ts?\n}")},125:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeBigIntStream = void 0;\nconst bytesToBigInt_1 = __webpack_require__(/*! ../converter/bytesToBigInt */ 1251);\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeBigIntStream = async (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.BigInt) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding bigint`);\n    }\n    const count = typeByte & 7;\n    const isNegative = Boolean(typeByte & 8);\n    if (count === 0) {\n        return isNegative ? -0n : 0n;\n    }\n    const bytesCount = await stream.readStreamBytes(count);\n    const encodeCount = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    const encodeBytes = await stream.readStreamBytes(encodeCount);\n    const bint = (0, bytesToBigInt_1.bytesToBigInt)(encodeBytes);\n    return isNegative ? -bint : bint;\n};\nexports.decodeBigIntStream = decodeBigIntStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeBigIntStream.ts?\n}')},137:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeArray = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decode_1 = __webpack_require__(/*! ./decode */ 6842);\nconst decodeInteger_1 = __webpack_require__(/*! ./decodeInteger */ 2186);\nconst decodeArray = (typeByte, stream, options, initArr = []) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Array) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding array`);\n    }\n    const isKeyValueEncoding = typeByte & 8;\n    const bytesCount = typeByte & 7;\n    if (bytesCount === 0) {\n        return initArr;\n    }\n    const arrayLen = (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(bytesCount));\n    const itemsCoint = isKeyValueEncoding ? (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(bytesCount)) : arrayLen;\n    const arr = initArr;\n    arr.length = arrayLen;\n    if (isKeyValueEncoding) {\n        for (let i = 0; i < itemsCoint; i += 1) {\n            const key = (0, decodeInteger_1.decodeInteger)(stream.readByte(), stream);\n            const value = (0, decode_1.decode)(stream.readByte(), stream, options);\n            arr[key] = value;\n        }\n    }\n    else {\n        for (let i = 0; i < arrayLen; i += 1) {\n            const byte = stream.readByte();\n            if (byte === EConstantByteCode_1.EConstantByteCode.Empty_Value) {\n                continue;\n            }\n            const value = (0, decode_1.decode)(byte, stream, options);\n            arr[i] = value;\n        }\n    }\n    return arr;\n};\nexports.decodeArray = decodeArray;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeArray.ts?\n}')},141:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeRef = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst isInteger_1 = __webpack_require__(/*! ../utils/vars/isInteger */ 64);\nconst encodeRef = (mode, refId, options) => {\n    if (!(0, isInteger_1.isInteger)(refId)) {\n        throw new Error(`Expecting "integer" type, received "${refId}" (${typeof refId})`);\n    }\n    if (Math.abs(refId) > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Can not encode unsafe integer`);\n    }\n    const msg = [];\n    const bytes = (0, integerToBytes_1.integerToBytes)(refId);\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Refs\n        | (mode === \'copy\' ? 8 : 0)\n        | (7 & bytes.length)));\n    // encode bytes\n    msg.push((0, toChar_1.toChar)(...bytes));\n    return msg.join(\'\');\n};\nexports.encodeRef = encodeRef;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeRef.ts?\n}')},320:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeSetStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeStream_1 = __webpack_require__(/*! ./decodeStream */ 7538);\nconst decodeSetStream = async (typeByte, stream, options, initSet = new Set()) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Set) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding set`);\n    }\n    const bytesCount = typeByte & 7;\n    if (bytesCount === 0) {\n        return initSet;\n    }\n    const count = (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(bytesCount));\n    const set = initSet;\n    for (let i = 0; i < count; i += 1) {\n        const value = await (0, decodeStream_1.decodeStream)(await stream.readStreamByte(), stream, options);\n        set.add(value);\n    }\n    return set;\n};\nexports.decodeSetStream = decodeSetStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeSetStream.ts?\n}')},479:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeString = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst EMPTY_STRING_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.String & 240);\nconst encodeString = (value) => {\n    if (typeof value !== 'string') {\n        throw new Error(`Expecting \"string\" type, received \"${value}\" (${typeof value})`);\n    }\n    if (value === '') {\n        return EMPTY_STRING_BYTE_CHAR;\n    }\n    const msg = [];\n    const encoder = new TextEncoder();\n    const encodeBytes = encoder.encode(value);\n    if (encodeBytes.byteLength > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Too large string. ${encodeBytes.byteLength} bytes, limit ${constants_1.MAX_7_BYTES_INTEGER}`);\n    }\n    const bytes = (0, integerToBytes_1.integerToBytes)(encodeBytes.byteLength);\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.String | (7 & bytes.length)));\n    // length bytes\n    msg.push((0, toChar_1.toChar)(...bytes));\n    // encode bytes\n    msg.push((0, toChar_1.toChar)(...encodeBytes));\n    return msg.join('');\n};\nexports.encodeString = encodeString;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeString.ts?\n}")},507:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createEncodeOptions = void 0;\nconst createEncodeOptions = () => {\n    return {\n        refs: {\n            enabled: false\n        },\n        context: {\n            refMap: new Map(),\n            refCopy: new Map(),\n        },\n        primitives: {\n            objectWrappersAsPrimitiveValue: false,\n        },\n        objects: {\n            classInstanceConstructorNameKey: '__jsbtConstructorName',\n        }\n    };\n};\nexports.createEncodeOptions = createEncodeOptions;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/options/createEncodeOptions.ts?\n}")},531:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.calculateByteCountVariants = void 0;\nconst integerToBytes_1 = __webpack_require__(/*! ../../converter/integerToBytes */ 9670);\nconst getTypedArrayByteCount_1 = __webpack_require__(/*! ./getTypedArrayByteCount */ 598);\nconst calculateByteCountVariants = (tarr) => {\n    const arr = tarr instanceof ArrayBuffer ? new Uint8Array(tarr) : tarr;\n    const bytesPerElement = (0, getTypedArrayByteCount_1.getBytesPerElement)(arr);\n    const resutls = {\n        envValueSize: arr.byteLength,\n        encKeyValueSize: 0,\n    };\n    for (let i = 0; i < arr.length; i += 1) {\n        const num = arr[i];\n        if (num) {\n            const bytes = (0, integerToBytes_1.integerToBytes)(i);\n            resutls.encKeyValueSize +=\n                /* type */ 1\n                    + /* int */ +(i > 0 ? bytes.length : 0)\n                    + bytesPerElement;\n        }\n    }\n    return resutls;\n};\nexports.calculateByteCountVariants = calculateByteCountVariants;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/typedArrays/calculateByteCountVariants.ts?\n}')},598:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getBytesPerElement = void 0;\nconst getBytesPerElement = (arr) => {\n    if (arr instanceof ArrayBuffer) {\n        return 1;\n    }\n    return arr.BYTES_PER_ELEMENT;\n};\nexports.getBytesPerElement = getBytesPerElement;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/typedArrays/getTypedArrayByteCount.ts?\n}')},632:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytesToUtf16 = void 0;\nconst bytesToUtf16 = (bytes) => {\n    const msg = [];\n    const len = Array.isArray(bytes) ? bytes.length : bytes.byteLength;\n    for (let i = 0; i < len; i += 1) {\n        // trailing bytes\n        const currentByte = bytes[i];\n        const nextByte = bytes[i + 1];\n        // leading bytes\n        if (nextByte >= 0xD8 && nextByte <= 0xDB // leading bytes\n            || nextByte >= 0xDC && nextByte <= 0xDF // trailing bytes\n        ) {\n            msg.push(String.fromCharCode((nextByte << 8) | currentByte));\n            i += 1;\n            continue;\n        }\n        msg.push(String.fromCharCode(currentByte));\n    }\n    return msg.join('');\n};\nexports.bytesToUtf16 = bytesToUtf16;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/converter/bytesToUtf16.ts?\n}")},1251:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.bytesToBigInt = void 0;\nconst bytesToBigInt = (bytes) => {\n    const len = Array.isArray(bytes) ? bytes.length : bytes.byteLength;\n    if (len === 0) {\n        return 0n;\n    }\n    let bint = 0n;\n    for (let i = 0; i < len; i += 1) {\n        const byte = BigInt(bytes[i]);\n        bint = (byte << BigInt(8 * i)) | bint;\n    }\n    return bint;\n};\nexports.bytesToBigInt = bytesToBigInt;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/converter/bytesToBigInt.ts?\n}')},1310:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeFloat = void 0;\nconst doubleToBytes_1 = __webpack_require__(/*! ../converter/doubleToBytes */ 6113);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst isFloat_1 = __webpack_require__(/*! ../utils/vars/isFloat */ 4392);\nconst encodeFloat = (value, mapping = true) => {\n    if (!(0, isFloat_1.isFloat)(value)) {\n        throw new Error(`Expecting "float" type, received "${value}" (${typeof value})`);\n    }\n    const bytes = (0, doubleToBytes_1.doubleToBytes)(value);\n    const msg = [];\n    const mappedBytes = [];\n    let byteMap = 0x0;\n    if (mapping) {\n        for (let i = 0; i < 8; i += 1) {\n            const byte = bytes[i];\n            if (byte) {\n                byteMap = byteMap + 2 ** (7 - i);\n                mappedBytes.push(byte);\n            }\n        }\n    }\n    // trim bytes\n    while (!bytes[0] && bytes.length) {\n        bytes.shift();\n    }\n    // no reason to use mapping if only 2 bytes could be missed\n    const isMapping = mapping && byteMap && mappedBytes.length < (bytes.length - 1);\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Float |\n        (7 & ((isMapping ? mappedBytes.length : bytes.length) - 1)) |\n        (isMapping ? 8 : 0)));\n    if (isMapping) {\n        //mapping byte\n        msg.push((0, toChar_1.toChar)(byteMap));\n    }\n    // encode bytes\n    msg.push((0, toChar_1.toChar)(...(isMapping ? mappedBytes : bytes)));\n    return msg.join(\'\');\n};\nexports.encodeFloat = encodeFloat;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeFloat.ts?\n}')},1365:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeNaN = void 0;\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst NAN_BYTE = (0, toChar_1.toChar)(EConstantByteCode_1.EConstantByteCode.NaN);\nconst encodeNaN = () => {\n    return NAN_BYTE;\n};\nexports.encodeNaN = encodeNaN;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeNaN.ts?\n}')},1417:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeObject = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decode_1 = __webpack_require__(/*! ./decode */ 6842);\nconst decodeObject = (typeByte, stream, options, initObj = {}) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Object) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding object`);\n    }\n    const bytesCount = typeByte & 7;\n    if (bytesCount === 0) {\n        return initObj;\n    }\n    const count = (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(bytesCount));\n    const isClassInstance = Boolean(typeByte & 8);\n    const constructorName = isClassInstance ? (0, decode_1.decode)(null, stream, options) : null;\n    const obj = initObj;\n    for (let i = 0; i < count; i += 1) {\n        const key = (0, decode_1.decode)(null, stream, options);\n        const value = (0, decode_1.decode)(null, stream, options);\n        obj[key] = value;\n    }\n    if (isClassInstance) {\n        const constructorNameKey = options.objects.classInstanceConstructorNameKey;\n        if (constructorNameKey !== null) {\n            const classConstructor = options.objects.factories[constructorName];\n            if (classConstructor) {\n                Object.setPrototypeOf(obj, classConstructor.prototype);\n            }\n            else {\n                Object.defineProperty(obj, constructorNameKey, {\n                    value: constructorName,\n                    configurable: true,\n                    enumerable: false,\n                    writable: false,\n                });\n            }\n        }\n    }\n    return obj;\n};\nexports.decodeObject = decodeObject;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeObject.ts?\n}')},1478:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.isSet = void 0;\nconst isSet = (value) => {\n    return value instanceof Set;\n};\nexports.isSet = isSet;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isSet.ts?\n}')},1550:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeConstantStream = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeConstant_1 = __webpack_require__(/*! ./decodeConstant */ 8494);\nconst decodeConstantStream = async (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Constant) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding contant`);\n    }\n    if (!decodeConstant_1.constantMap.has(typeByte)) {\n        throw new Error('Not supported contsant for decoding');\n    }\n    return decodeConstant_1.constantMap.get(typeByte);\n};\nexports.decodeConstantStream = decodeConstantStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeConstantStream.ts?\n}")},1625:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeArrayStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeIntegerStream_1 = __webpack_require__(/*! ./decodeIntegerStream */ 9330);\nconst decodeStream_1 = __webpack_require__(/*! ./decodeStream */ 7538);\nconst decodeArrayStream = async (typeByte, stream, options, initArr = []) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Array) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding array`);\n    }\n    const isKeyValueEncoding = typeByte & 8;\n    const bytesCount = typeByte & 7;\n    if (bytesCount === 0) {\n        return initArr;\n    }\n    const arrayLen = (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(bytesCount));\n    const itemsCoint = isKeyValueEncoding ? (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(bytesCount)) : arrayLen;\n    const arr = initArr;\n    arr.length = arrayLen;\n    if (isKeyValueEncoding) {\n        for (let i = 0; i < itemsCoint; i += 1) {\n            const key = await (0, decodeIntegerStream_1.decodeIntegerStream)(await stream.readStreamByte(), stream);\n            const value = await (0, decodeStream_1.decodeStream)(await stream.readStreamByte(), stream, options);\n            arr[key] = value;\n        }\n    }\n    else {\n        for (let i = 0; i < arrayLen; i += 1) {\n            const byte = await stream.readStreamByte();\n            if (byte === EConstantByteCode_1.EConstantByteCode.Empty_Value) {\n                continue;\n            }\n            const value = await (0, decodeStream_1.decodeStream)(byte, stream, options);\n            arr[i] = value;\n        }\n    }\n    return arr;\n};\nexports.decodeArrayStream = decodeArrayStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeArrayStream.ts?\n}')},1690:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeMap = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decode_1 = __webpack_require__(/*! ./decode */ 6842);\nconst decodeMap = (typeByte, stream, options, initMap = new Map()) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Map) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding map`);\n    }\n    const bytesCount = typeByte & 7;\n    if (bytesCount === 0) {\n        return initMap;\n    }\n    const count = (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(bytesCount));\n    const map = initMap;\n    for (let i = 0; i < count; i += 1) {\n        const key = (0, decode_1.decode)(stream.readByte(), stream, options);\n        const value = (0, decode_1.decode)(stream.readByte(), stream, options);\n        map.set(key, value);\n    }\n    return map;\n};\nexports.decodeMap = decodeMap;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeMap.ts?\n}')},1802:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeInfinity = void 0;\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst POS_INFINITY_CHR = (0, toChar_1.toChar)(EConstantByteCode_1.EConstantByteCode.Pos_Infinity);\nconst NEG_INFINITY_CHR = (0, toChar_1.toChar)(EConstantByteCode_1.EConstantByteCode.Neg_Infinity);\nconst encodeInfinity = (value) => {\n    if (value !== Infinity && value !== -Infinity) {\n        throw new Error(`Expecting "Infinity", received "${value}" (${typeof value})`);\n    }\n    return value > 0 ? POS_INFINITY_CHR : NEG_INFINITY_CHR;\n};\nexports.encodeInfinity = encodeInfinity;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeInfinity.ts?\n}')},1884:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.isMap = void 0;\nconst isMap = (value) => {\n    return value instanceof Map;\n};\nexports.isMap = isMap;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isMap.ts?\n}')},2031:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeNull = void 0;\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst NULL_BYTE = (0, toChar_1.toChar)(EConstantByteCode_1.EConstantByteCode.Null);\nconst encodeNull = () => {\n    return NULL_BYTE;\n};\nexports.encodeNull = encodeNull;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeNull.ts?\n}')},2037:function(__unused_webpack_module,exports,__webpack_require__){eval('{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeRefStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst ByteStream_1 = __importDefault(__webpack_require__(/*! ../reader/ByteStream */ 2043));\nconst decode_1 = __webpack_require__(/*! ./decode */ 6842);\nconst createDecodeOptions_1 = __webpack_require__(/*! ./options/createDecodeOptions */ 5223);\nconst decodeRefStream = async (typeByte, stream, options) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Refs) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding ref`);\n    }\n    const isCopy = Boolean(typeByte & 8);\n    const count = typeByte & 7;\n    const id = count === 0 ? 0 : (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(count));\n    const refs = options.context.refs;\n    if (!(id in refs)) {\n        throw new Error(`Incorrect ref ID ${id}, max id is ${refs.length}`);\n    }\n    if (isCopy) {\n        const refSlice = options.context.refByteSlice[id];\n        const slice = options.context.readBytes.slice(refSlice.index, refSlice.index + refSlice.length);\n        const decOptions = (0, createDecodeOptions_1.createDecodeOptions)();\n        decOptions.context = options.context;\n        const st = new ByteStream_1.default(slice);\n        st.completeStream();\n        const copy = (0, decode_1.decode)(null, st, decOptions);\n        return copy;\n    }\n    return refs[id];\n};\nexports.decodeRefStream = decodeRefStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeRefStream.ts?\n}')},2043:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass ByteStream {\n    constructor(msg = []) {\n        this._msgArrIndex = 0;\n        this._msgChrIndex = 0;\n        this._restByte = 0;\n        this._isStreamComplete = false;\n        this._isEOF = false;\n        this._waitingPromise = null;\n        this._waitingPromiseResolver = null;\n        this._waitingRejectTimeout = null;\n        this._readBytes = [];\n        this._msg = Array.isArray(msg) ? [...msg] : [msg];\n    }\n    getReadBytesIndex() {\n        return this._readBytes.length;\n    }\n    getReadBytes() {\n        return this._readBytes;\n    }\n    addMessage(msg) {\n        if (Array.isArray(msg)) {\n            this._msg.push(...msg);\n        }\n        else {\n            this._msg.push(msg);\n        }\n        if (this._waitingPromise && this._waitingPromiseResolver) {\n            this._waitingPromiseResolver();\n        }\n    }\n    completeStream(msg = []) {\n        this.addMessage(msg);\n        this._isStreamComplete = true;\n    }\n    isCompleteMessage() {\n        return this._isStreamComplete;\n    }\n    isEOF() {\n        return this._isEOF;\n    }\n    waitMessages(timeout) {\n        if (this._waitingPromise) {\n            return this._waitingPromise;\n        }\n        if (this._isStreamComplete) {\n            return Promise.reject('Can not wait completed stream');\n        }\n        const promise = new Promise((resolve, reject) => {\n            this._waitingPromiseResolver = resolve;\n            this._waitingRejectTimeout = setTimeout(() => {\n                reject(`Waiting timeout ${timeout}ms is riched`);\n            }, timeout);\n        }).finally(() => {\n            if (this._waitingRejectTimeout) {\n                clearTimeout(this._waitingRejectTimeout);\n                this._waitingRejectTimeout = null;\n            }\n            this._waitingPromise = null;\n            this._waitingPromiseResolver = null;\n        });\n        this._waitingPromise = promise;\n        return promise;\n    }\n    async readStreamBytes(count = 1, timeout = 30000) {\n        const bytes = new Uint8Array(count);\n        let bytesLen = 0;\n        while (bytesLen < count) {\n            if (this._restByte) {\n                bytes[bytesLen] = this._restByte;\n                this._readBytes.push(this._restByte);\n                this._restByte = 0;\n                bytesLen += 1;\n                continue;\n            }\n            if (!(this._msgArrIndex in this._msg)) {\n                if (!this._isStreamComplete) {\n                    await this.waitMessages(timeout);\n                    continue;\n                }\n                this._isEOF = true;\n                throw new Error(`Can not read ${count - bytesLen} bytes`);\n            }\n            let charCode = NaN;\n            const block = this._msg[this._msgArrIndex];\n            if (typeof block === 'number') {\n                charCode = block;\n                this._msgChrIndex = 0;\n                delete this._msg[this._msgArrIndex];\n                this._msgArrIndex += 1;\n            }\n            else {\n                charCode = block.charCodeAt(this._msgChrIndex);\n                if (charCode > 255) {\n                    this._restByte = (charCode & 0xff00) >>> 8;\n                    charCode = charCode & 0xff;\n                }\n                this._msgChrIndex += 1;\n            }\n            if (Number.isNaN(charCode)) {\n                delete this._msg[this._msgArrIndex];\n                this._msgArrIndex += 1;\n                this._msgChrIndex = 0;\n                continue;\n            }\n            bytes[bytesLen] = charCode;\n            this._readBytes.push(charCode);\n            bytesLen += 1;\n        }\n        return bytes;\n    }\n    async readStreamByte() {\n        return (await this.readStreamBytes(1))[0];\n    }\n    readBytes(count = 1) {\n        if (!this._isStreamComplete) {\n            throw new Error('Sync bytes read is allowed only for completed stream');\n        }\n        const bytes = new Uint8Array(count);\n        let bytesLen = 0;\n        while (bytesLen < count) {\n            if (this._restByte) {\n                bytes[bytesLen] = this._restByte;\n                this._readBytes.push(this._restByte);\n                this._restByte = 0;\n                bytesLen += 1;\n                continue;\n            }\n            if (!(this._msgArrIndex in this._msg)) {\n                this._isEOF = true;\n                throw new Error(`Can not read ${count - bytesLen} bytes`);\n            }\n            let charCode = NaN;\n            const block = this._msg[this._msgArrIndex];\n            if (typeof block === 'number') {\n                charCode = block;\n                this._msgChrIndex = 0;\n                delete this._msg[this._msgArrIndex];\n                this._msgArrIndex += 1;\n            }\n            else {\n                charCode = block.charCodeAt(this._msgChrIndex);\n                if (charCode > 255) {\n                    this._restByte = (charCode & 0xff00) >>> 8;\n                    charCode = charCode & 0xff;\n                }\n                this._msgChrIndex += 1;\n            }\n            if (Number.isNaN(charCode)) {\n                delete this._msg[this._msgArrIndex];\n                this._msgArrIndex += 1;\n                this._msgChrIndex = 0;\n                continue;\n            }\n            bytes[bytesLen] = charCode;\n            this._readBytes.push(charCode);\n            bytesLen += 1;\n        }\n        return bytes;\n    }\n    readByte() {\n        return this.readBytes(1)[0];\n    }\n}\nexports[\"default\"] = ByteStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/reader/ByteStream.ts?\n}")},2088:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeSet = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst isSet_1 = __webpack_require__(/*! ../utils/vars/isSet */ 1478);\nconst encode_1 = __webpack_require__(/*! ./encode */ 4650);\nconst EMPTY_SET_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Set & 240);\nconst encodeSet = (set, options) => {\n    if (!(0, isSet_1.isSet)(set)) {\n        throw new Error(`Expecting "set" type, received "${set}" (${typeof set})`);\n    }\n    if (set.size === 0) {\n        return EMPTY_SET_BYTE_CHAR;\n    }\n    if (set.size > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided set has too many items, limit ${constants_1.MAX_7_BYTES_INTEGER}, received ${set.size}`);\n    }\n    const sizeBytes = (0, integerToBytes_1.integerToBytes)(set.size);\n    const msg = [];\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Set\n        | (7 & sizeBytes.length)));\n    // count\n    msg.push((0, toChar_1.toChar)(...sizeBytes));\n    set.forEach((value) => {\n        msg.push((0, encode_1.encode)(value, options));\n    });\n    return msg.join(\'\');\n};\nexports.encodeSet = encodeSet;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeSet.ts?\n}')},2133:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeBigInt = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst bigIntToBytes_1 = __webpack_require__(/*! ../converter/bigIntToBytes */ 4379);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst isBigInt_1 = __webpack_require__(/*! ../utils/vars/isBigInt */ 3423);\nconst ZERO_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.BigInt & 240);\nconst encodeBigInt = (value) => {\n    if (!(0, isBigInt_1.isBigInt)(value)) {\n        throw new Error(`Expecting "bigint" type, received "${value}" (${typeof value})`);\n    }\n    if (value === 0n) {\n        return ZERO_BYTE_CHAR;\n    }\n    const val = value < 0n ? -value : value;\n    const isPositive = value > 0;\n    const msg = [];\n    const bytes = (0, bigIntToBytes_1.bigIntToBytes)(val);\n    const lenBytes = (0, integerToBytes_1.integerToBytes)(bytes.length);\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.BigInt | (7 & lenBytes.length) | (isPositive ? 0 : 8)));\n    // length bytes\n    msg.push((0, toChar_1.toChar)(...lenBytes));\n    // encode bytes\n    msg.push((0, toChar_1.toChar)(...bytes.map((i) => Number(i))));\n    return msg.join(\'\');\n};\nexports.encodeBigInt = encodeBigInt;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeBigInt.ts?\n}')},2157:function(__unused_webpack_module,exports,__webpack_require__){eval('{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeRef = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst ByteStream_1 = __importDefault(__webpack_require__(/*! ../reader/ByteStream */ 2043));\nconst decode_1 = __webpack_require__(/*! ./decode */ 6842);\nconst createDecodeOptions_1 = __webpack_require__(/*! ./options/createDecodeOptions */ 5223);\nconst decodeRef = (typeByte, stream, options) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Refs) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding ref`);\n    }\n    const isCopy = Boolean(typeByte & 8);\n    const count = typeByte & 7;\n    const id = count === 0 ? 0 : (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(count));\n    const refs = options.context.refs;\n    if (!(id in refs)) {\n        throw new Error(`Incorrect ref ID ${id}, max id is ${refs.length}`);\n    }\n    if (isCopy) {\n        const refSlice = options.context.refByteSlice[id];\n        const slice = options.context.readBytes.slice(refSlice.index, refSlice.index + refSlice.length);\n        const decOptions = (0, createDecodeOptions_1.createDecodeOptions)();\n        decOptions.context = options.context;\n        const st = new ByteStream_1.default(slice);\n        st.completeStream();\n        const copy = (0, decode_1.decode)(null, st, decOptions);\n        return copy;\n    }\n    return refs[id];\n};\nexports.decodeRef = decodeRef;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeRef.ts?\n}')},2186:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeInteger = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeInteger = (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Integer) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding integer`);\n    }\n    const count = typeByte & 7;\n    const isNegative = Boolean(typeByte & 8);\n    if (count === 0) {\n        return isNegative ? -0 : 0;\n    }\n    const bytesCount = stream.readBytes(count);\n    const int = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    return isNegative ? -int : int;\n};\nexports.decodeInteger = decodeInteger;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeInteger.ts?\n}')},2457:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeArray = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst getFilledItemsCount_1 = __webpack_require__(/*! ../utils/arrays/getFilledItemsCount */ 3081);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst encodeEmptyValue_1 = __webpack_require__(/*! ./encodeEmptyValue */ 4408);\nconst encodeInteger_1 = __webpack_require__(/*! ./encodeInteger */ 7450);\nconst encode_1 = __webpack_require__(/*! ./encode */ 4650);\nconst EMPTY_ARRAY_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Array & 240);\nconst SPARSE_RATE = 0.5;\nconst encodeArray = (arr, options) => {\n    if (!Array.isArray(arr)) {\n        throw new Error(`Expecting "array" type, received "${arr}" (${typeof arr})`);\n    }\n    if (arr.length === 0) {\n        return EMPTY_ARRAY_BYTE_CHAR;\n    }\n    if (arr.length > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided array has too large length, limit ${constants_1.MAX_7_BYTES_INTEGER}, received ${arr.length}`);\n    }\n    const filledCount = (0, getFilledItemsCount_1.getFilledItemsCount)(arr);\n    const isSparseEncoding = filledCount / arr.length < SPARSE_RATE;\n    const bytes = (0, integerToBytes_1.integerToBytes)(arr.length);\n    const msg = [];\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Array\n        | ((7 & bytes.length)\n            | (isSparseEncoding ? 8 : 0))));\n    // length\n    msg.push((0, toChar_1.toChar)(...bytes));\n    if (isSparseEncoding) {\n        // Sparse Array Encoding\n        // Encode only filled items with keys\n        // Items count\n        const countBytes = (0, integerToBytes_1.integerToBytes)(filledCount, bytes.length);\n        msg.push((0, toChar_1.toChar)(...countBytes));\n        arr.forEach((item, index) => {\n            msg.push((0, encodeInteger_1.encodeInteger)(index));\n            msg.push((0, encode_1.encode)(item, options));\n        });\n    }\n    else {\n        // Dense Array Encoding\n        // Encode all items including Empty Values\n        for (let i = 0; i < arr.length; i += 1) {\n            const isEmptyValue = !(String(i) in arr);\n            msg.push(isEmptyValue ? (0, encodeEmptyValue_1.encodeEmptyValue)() : (0, encode_1.encode)(arr[i], options));\n        }\n    }\n    return msg.join(\'\');\n};\nexports.encodeArray = encodeArray;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeArray.ts?\n}')},2462:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getBytesSizeForString = void 0;\nconst getBytesSizeForString = (str) => {\n    let size = 0;\n    for (let i = 0; i < str.length; i += 1) {\n        const chr = str[i];\n        for (let codeAt = 0; codeAt < 2; codeAt += 1) {\n            const code = chr.charCodeAt(codeAt);\n            if (isNaN(code)) {\n                continue;\n            }\n            if (code < 256) {\n                size += 1;\n            }\n            else {\n                size += 2;\n            }\n        }\n    }\n    return size;\n};\nexports.getBytesSizeForString = getBytesSizeForString;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/converter/getBytesSizeForString.ts?\n}')},2519:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodePrimitiveObjectWrapper = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decode_1 = __webpack_require__(/*! ./decode */ 6842);\nconst decodePrimitiveObjectWrapper = (typeByte, stream, options) => {\n    if (typeByte !== (ETypeByteCode_1.ETypeByteCode.Instruction | 0)) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding primitive object wrapper`);\n    }\n    const value = (0, decode_1.decode)(stream.readByte(), stream, options);\n    switch (typeof value) {\n        case 'string': return new String(value);\n        case 'boolean': return new Boolean(value);\n        case 'number': return new Number(value);\n    }\n    throw new Error(`Can not create Primitive Object Wrapper for value ${value}, type ${typeof value}`);\n};\nexports.decodePrimitiveObjectWrapper = decodePrimitiveObjectWrapper;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodePrimitiveObjectWrapper.ts?\n}")},2525:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTypedArray = void 0;\nconst isTypedArray = (value) => {\n    return (typeof (ArrayBuffer) !== 'undefined' && value instanceof ArrayBuffer ||\n        typeof (Int8Array) !== 'undefined' && value instanceof Int8Array ||\n        typeof (Uint8Array) !== 'undefined' && value instanceof Uint8Array ||\n        typeof (Uint8ClampedArray) !== 'undefined' && value instanceof Uint8ClampedArray ||\n        typeof (Int16Array) !== 'undefined' && value instanceof Int16Array ||\n        typeof (Uint16Array) !== 'undefined' && value instanceof Uint16Array ||\n        typeof (Int32Array) !== 'undefined' && value instanceof Int32Array ||\n        typeof (Uint32Array) !== 'undefined' && value instanceof Uint32Array ||\n        typeof (Float32Array) !== 'undefined' && value instanceof Float32Array ||\n        typeof (Float64Array) !== 'undefined' && value instanceof Float64Array ||\n        typeof (BigInt64Array) !== 'undefined' && value instanceof BigInt64Array ||\n        typeof (BigUint64Array) !== 'undefined' && value instanceof BigUint64Array);\n};\nexports.isTypedArray = isTypedArray;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isTypedArray.ts?\n}")},2640:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.MAX_DATE_INTEGER = exports.MAX_7_BYTES_INTEGER = void 0;\nexports.MAX_7_BYTES_INTEGER = 9007199254740991; // Number.MAX_SAFE_NUMBER;\nexports.MAX_DATE_INTEGER = 8640000000000000;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/constants.ts?\n}')},2862:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeFloatStream = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeFloatStream = async (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Float) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding float`);\n    }\n    const count = (typeByte & 7) + 1;\n    let map = 0;\n    if (typeByte & 8) {\n        // custom map\n        map = await stream.readStreamByte();\n    }\n    else {\n        for (let i = 0; i < count; i += 1) {\n            map = map | (1 << i);\n        }\n    }\n    const bytesCount = await stream.readStreamBytes(count);\n    const floatBytes = new Uint8Array(8);\n    let byteIndex = 0;\n    for (let i = 0; i < 8; i += 1) {\n        if (map & (128 >>> i)) {\n            floatBytes[i] = bytesCount[byteIndex];\n            byteIndex += 1;\n        }\n    }\n    const float = new Float64Array(floatBytes.buffer);\n    return float[0];\n};\nexports.decodeFloatStream = decodeFloatStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeFloatStream.ts?\n}')},3081:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getFilledItemsCount = void 0;\nconst getFilledItemsCount = (arr) => {\n    let count = 0;\n    // Unassigned values are not iterated in a forEach loop.\n    arr.forEach(() => {\n        count += 1;\n    });\n    return count;\n};\nexports.getFilledItemsCount = getFilledItemsCount;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/arrays/getFilledItemsCount.ts?\n}')},3386:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeSymbol = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst getBytesSizeForString_1 = __webpack_require__(/*! ../converter/getBytesSizeForString */ 2462);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst encodeSymbol = (value) => {\n    if (typeof value !== \'symbol\') {\n        throw new Error(`Expecting "symbol" type, received "${String(value)}" (${typeof value})`);\n    }\n    const msg = [];\n    const key = Symbol.keyFor(value);\n    if (key === undefined) {\n        throw new Error(`Not found key for symbol ${String(value)}`);\n    }\n    const bytesCount = (0, getBytesSizeForString_1.getBytesSizeForString)(key);\n    if (bytesCount > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Too large symbol key. ${bytesCount} bytes, limit ${constants_1.MAX_7_BYTES_INTEGER}`);\n    }\n    const bytes = (0, integerToBytes_1.integerToBytes)(bytesCount);\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Symbol | (7 & bytes.length)));\n    if (bytes.length) {\n        // length bytes\n        msg.push((0, toChar_1.toChar)(...bytes));\n    }\n    if (key) {\n        // encode bytes\n        msg.push(key);\n    }\n    return msg.join(\'\');\n};\nexports.encodeSymbol = encodeSymbol;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeSymbol.ts?\n}')},3423:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBigInt = void 0;\nconst isBigInt = (value) => {\n    return typeof value === 'bigint';\n};\nexports.isBigInt = isBigInt;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isBigInt.ts?\n}")},3461:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeBigInt = void 0;\nconst bytesToBigInt_1 = __webpack_require__(/*! ../converter/bytesToBigInt */ 1251);\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeBigInt = (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.BigInt) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding bigint`);\n    }\n    const count = typeByte & 7;\n    const isNegative = Boolean(typeByte & 8);\n    if (count === 0) {\n        return isNegative ? -0n : 0n;\n    }\n    const bytesCount = stream.readBytes(count);\n    const encodeCount = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    const encodeBytes = stream.readBytes(encodeCount);\n    const bint = (0, bytesToBigInt_1.bytesToBigInt)(encodeBytes);\n    return isNegative ? -bint : bint;\n};\nexports.decodeBigInt = decodeBigInt;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeBigInt.ts?\n}')},3578:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeMap = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst isMap_1 = __webpack_require__(/*! ../utils/vars/isMap */ 1884);\nconst encode_1 = __webpack_require__(/*! ./encode */ 4650);\nconst EMPTY_MAP_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Map & 240);\nconst encodeMap = (map, options) => {\n    if (!(0, isMap_1.isMap)(map)) {\n        throw new Error(`Expecting "map" type, received "${map}" (${typeof map})`);\n    }\n    if (map.size === 0) {\n        return EMPTY_MAP_BYTE_CHAR;\n    }\n    if (map.size > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided map has too many items, limit ${constants_1.MAX_7_BYTES_INTEGER}, received ${map.size}`);\n    }\n    const sizeBytes = (0, integerToBytes_1.integerToBytes)(map.size);\n    const msg = [];\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Map\n        | (7 & sizeBytes.length)));\n    // count\n    msg.push((0, toChar_1.toChar)(...sizeBytes));\n    map.forEach((value, key) => {\n        msg.push((0, encode_1.encode)(key, options));\n        msg.push((0, encode_1.encode)(value, options));\n    });\n    return msg.join(\'\');\n};\nexports.encodeMap = encodeMap;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeMap.ts?\n}')},3815:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeTypedArray = exports.dataViewGetter = exports.typedArrayConstructorByType = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst ETypedArrayByteCode_1 = __webpack_require__(/*! ../enums/ETypedArrayByteCode */ 5409);\nconst getTypedArrayByteCount_1 = __webpack_require__(/*! ../utils/typedArrays/getTypedArrayByteCount */ 598);\nconst decodeInteger_1 = __webpack_require__(/*! ./decodeInteger */ 2186);\nexports.typedArrayConstructorByType = {};\nif (typeof (Uint8Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.ArrayBuffer] = Uint8Array;\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Uint8Array] = Uint8Array;\n}\nif (typeof (Int8Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Int8Array] = Int8Array;\n}\nif (typeof (Uint8ClampedArray) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Uint8ClampedArray] = Uint8ClampedArray;\n}\nif (typeof (Int16Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Int16Array] = Int16Array;\n}\nif (typeof (Uint16Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Uint16Array] = Uint16Array;\n}\nif (typeof (Int32Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Int32Array] = Int32Array;\n}\nif (typeof (Uint32Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Uint32Array] = Uint32Array;\n}\nif (typeof (Float32Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Float32Array] = Float32Array;\n}\nif (typeof (Float64Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.Float64Array] = Float64Array;\n}\nif (typeof (BigInt64Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.BigInt64Array] = BigInt64Array;\n}\nif (typeof (BigUint64Array) !== 'undefined') {\n    exports.typedArrayConstructorByType[ETypedArrayByteCode_1.ETypedArrayByteCode.BigUint64Array] = BigUint64Array;\n}\nexports.dataViewGetter = {\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.ArrayBuffer]: 'getUint8',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Int8Array]: 'getInt8',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Uint8Array]: 'getUint8',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Uint8ClampedArray]: 'getUint8',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Int16Array]: 'getInt16',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Uint16Array]: 'getUint16',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Int32Array]: 'getInt32',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Uint32Array]: 'getUint32',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Float32Array]: 'getFloat32',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.Float64Array]: 'getFloat64',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.BigInt64Array]: 'getBigInt64',\n    [ETypedArrayByteCode_1.ETypedArrayByteCode.BigUint64Array]: 'getBigInt64',\n};\nconst decodeTypedArray = (typeByte, stream, options) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Typed_Array) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding typed array`);\n    }\n    const secondByte = stream.readByte();\n    const isKeyValueEncoding = secondByte & 64;\n    const itemsBytesCount = secondByte & 7;\n    const lengthBytesCount = (secondByte & 56) >>> 3;\n    const TypedArrayConstructor = exports.typedArrayConstructorByType[typeByte];\n    const tarr0 = new TypedArrayConstructor(0);\n    const bytesPerElement = (0, getTypedArrayByteCount_1.getBytesPerElement)(tarr0);\n    const len = isKeyValueEncoding\n        ? (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(lengthBytesCount))\n        : (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(itemsBytesCount));\n    const count = isKeyValueEncoding ? (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(itemsBytesCount)) : len;\n    const dataGetterName = exports.dataViewGetter[typeByte];\n    if (isKeyValueEncoding) {\n        const tarr = new TypedArrayConstructor(Math.round(len / bytesPerElement));\n        for (let i = 0; i < count; i += 1) {\n            const key = (0, decodeInteger_1.decodeInteger)(stream.readByte(), stream);\n            const valueBytes = stream.readBytes(bytesPerElement);\n            const view = new DataView(valueBytes.buffer);\n            tarr[key] = view[dataGetterName](0, true);\n        }\n        if (typeByte === ETypedArrayByteCode_1.ETypedArrayByteCode.ArrayBuffer) {\n            return tarr.buffer;\n        }\n        return tarr;\n    }\n    else {\n        const tarr = new TypedArrayConstructor(len);\n        const view = new DataView(stream.readBytes(bytesPerElement * len).buffer);\n        for (let i = 0; i < len; i += 1) {\n            tarr[i] = view[dataGetterName](i * bytesPerElement, true);\n        }\n        if (typeByte === ETypedArrayByteCode_1.ETypedArrayByteCode.ArrayBuffer) {\n            return tarr.buffer;\n        }\n        return tarr;\n    }\n};\nexports.decodeTypedArray = decodeTypedArray;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeTypedArray.ts?\n}")},3991:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodePrimitiveObjectWrapper = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst isPrimitiveObjectWrapper_1 = __webpack_require__(/*! ../utils/vars/isPrimitiveObjectWrapper */ 5825);\nconst encode_1 = __webpack_require__(/*! ./encode */ 4650);\nconst encodePrimitiveObjectWrapper = (obj, options) => {\n    if (!(0, isPrimitiveObjectWrapper_1.isPrimitiveObjectWrapper)(obj)) {\n        throw new Error(`Expecting Promitive Object Wrapper, received "${obj}" (${typeof obj})`);\n    }\n    const msg = [];\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Instruction & 240));\n    msg.push((0, encode_1.encode)(obj.valueOf(), options));\n    return msg.join(\'\');\n};\nexports.encodePrimitiveObjectWrapper = encodePrimitiveObjectWrapper;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodePrimitiveObjectWrapper.ts?\n}')},4379:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.bigIntToBytes = void 0;\nconst bigIntToBytes = (bint, byteSize = 0, bigEndianOrder = false) => {\n    if (bint < 0 && !byteSize) {\n        throw new Error(`byteSize param should be provided for negative bigInt ${bint}`);\n    }\n    const bytes = [];\n    let num = bint < 0 ? -(bint + 1n) : bint;\n    for (let i = 1; byteSize ? i <= byteSize : num; i += 1) {\n        bytes.push(num & 0xffn);\n        num = num >> 8n;\n    }\n    if (bint < 0) {\n        for (let i = 0; i < bytes.length; i += 1) {\n            bytes[i] = 255n - bytes[i];\n        }\n        //bytes.push(255n);\n    }\n    return bigEndianOrder ? bytes.reverse() : bytes;\n};\nexports.bigIntToBytes = bigIntToBytes;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/converter/bigIntToBytes.ts?\n}')},4382:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeDate = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeDate = (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Date) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding Date`);\n    }\n    const count = typeByte & 7;\n    const isNegative = Boolean(typeByte & 8);\n    if (count === 0) {\n        return new Date(0);\n    }\n    const bytesCount = stream.readBytes(count);\n    const int = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    return new Date(isNegative ? -int : int);\n};\nexports.decodeDate = decodeDate;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeDate.ts?\n}')},4392:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isFloat = void 0;\nconst isFloat = (value) => {\n    return typeof value === 'number'\n        && !Number.isInteger(value)\n        && Number.isFinite(value)\n        && value % 1 !== 0;\n};\nexports.isFloat = isFloat;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isFloat.ts?\n}")},4408:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeEmptyValue = void 0;\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst EMPTY_VALUE_BYTE_CHR = (0, toChar_1.toChar)(EConstantByteCode_1.EConstantByteCode.Empty_Value);\nconst encodeEmptyValue = () => {\n    return EMPTY_VALUE_BYTE_CHR;\n};\nexports.encodeEmptyValue = encodeEmptyValue;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeEmptyValue.ts?\n}')},4556:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.EConstantByteCode = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ./ETypeByteCode */ 6156);\nvar EConstantByteCode;\n(function (EConstantByteCode) {\n    EConstantByteCode[EConstantByteCode["FALSE"] = 0] = "FALSE";\n    EConstantByteCode[EConstantByteCode["TRUE"] = 1] = "TRUE";\n    EConstantByteCode[EConstantByteCode["Null"] = 2] = "Null";\n    EConstantByteCode[EConstantByteCode["Undefined"] = 3] = "Undefined";\n    EConstantByteCode[EConstantByteCode["NaN"] = 4] = "NaN";\n    EConstantByteCode[EConstantByteCode["Pos_Infinity"] = 5] = "Pos_Infinity";\n    EConstantByteCode[EConstantByteCode["Neg_Infinity"] = 6] = "Neg_Infinity";\n    EConstantByteCode[EConstantByteCode["Empty_Value"] = 7] = "Empty_Value";\n})(EConstantByteCode || (exports.EConstantByteCode = EConstantByteCode = {}));\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/enums/EConstantByteCode.ts?\n}')},4650:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = void 0;\nconst isClassInstance_1 = __webpack_require__(/*! ../utils/vars/isClassInstance */ 5761);\nconst isFloat_1 = __webpack_require__(/*! ../utils/vars/isFloat */ 4392);\nconst isInteger_1 = __webpack_require__(/*! ../utils/vars/isInteger */ 64);\nconst isMap_1 = __webpack_require__(/*! ../utils/vars/isMap */ 1884);\nconst isObject_1 = __webpack_require__(/*! ../utils/vars/isObject */ 9231);\nconst isPrimitiveObjectWrapper_1 = __webpack_require__(/*! ../utils/vars/isPrimitiveObjectWrapper */ 5825);\nconst isSet_1 = __webpack_require__(/*! ../utils/vars/isSet */ 1478);\nconst isTypedArray_1 = __webpack_require__(/*! ../utils/vars/isTypedArray */ 2525);\nconst encodeArray_1 = __webpack_require__(/*! ./encodeArray */ 2457);\nconst encodeBigInt_1 = __webpack_require__(/*! ./encodeBigInt */ 2133);\nconst encodeBoolean_1 = __webpack_require__(/*! ./encodeBoolean */ 5560);\nconst encodeClassInstance_1 = __webpack_require__(/*! ./encodeClassInstance */ 6475);\nconst encodeDate_1 = __webpack_require__(/*! ./encodeDate */ 6766);\nconst encodeFloat_1 = __webpack_require__(/*! ./encodeFloat */ 1310);\nconst encodeInfinity_1 = __webpack_require__(/*! ./encodeInfinity */ 1802);\nconst encodeInteger_1 = __webpack_require__(/*! ./encodeInteger */ 7450);\nconst encodeMap_1 = __webpack_require__(/*! ./encodeMap */ 3578);\nconst encodeNaN_1 = __webpack_require__(/*! ./encodeNaN */ 1365);\nconst encodeNull_1 = __webpack_require__(/*! ./encodeNull */ 2031);\nconst encodeObject_1 = __webpack_require__(/*! ./encodeObject */ 6537);\nconst encodePrimitiveObjectWrapper_1 = __webpack_require__(/*! ./encodePrimitiveObjectWrapper */ 3991);\nconst encodeRef_1 = __webpack_require__(/*! ./encodeRef */ 141);\nconst encodeSet_1 = __webpack_require__(/*! ./encodeSet */ 2088);\nconst encodeString_1 = __webpack_require__(/*! ./encodeString */ 479);\nconst encodeSymbol_1 = __webpack_require__(/*! ./encodeSymbol */ 3386);\nconst encodeTypedArray_1 = __webpack_require__(/*! ./encodeTypedArray */ 6247);\nconst encodeUndefined_1 = __webpack_require__(/*! ./encodeUndefined */ 7344);\nconst encode = (value, options) => {\n    const context = options.context;\n    const isRefEnabled = options.refs?.enabled || false;\n    let val = value;\n    if ((0, isPrimitiveObjectWrapper_1.isPrimitiveObjectWrapper)(value) && options.primitives.objectWrappersAsPrimitiveValue) {\n        val = value.valueOf(); // Primitive Object to Promitive Value\n    }\n    let refData = null;\n    if (isRefEnabled) {\n        refData = context.refMap.get(val) || null;\n        if (refData) {\n            if (!refData.encodedRefLink) {\n                refData.encodedRefLink = (0, encodeRef_1.encodeRef)('link', refData.refId, options);\n            }\n            return refData.encodedRefLink;\n        }\n        else {\n            const refId = context.refMap.size;\n            refData = {\n                refId: refId,\n                encodedRefLink: null,\n                encodedRefCopy: null,\n            };\n            context.refMap.set(val, refData);\n        }\n    }\n    let result = null;\n    let isRefAllowed = false;\n    const type = typeof val;\n    switch (type) {\n        case 'undefined': {\n            isRefAllowed = false;\n            result = (0, encodeUndefined_1.encodeUndefined)();\n            break;\n        }\n        case 'boolean': {\n            isRefAllowed = false;\n            result = (0, encodeBoolean_1.encodeBoolean)(val);\n            break;\n        }\n        case 'number': {\n            if ((0, isInteger_1.isInteger)(val)) {\n                isRefAllowed = val > 255 || val < -255;\n                result = (0, encodeInteger_1.encodeInteger)(val);\n                break;\n            }\n            if ((0, isFloat_1.isFloat)(val)) {\n                isRefAllowed = true;\n                result = (0, encodeFloat_1.encodeFloat)(val);\n                break;\n            }\n            if (Number.isNaN(val)) {\n                isRefAllowed = false;\n                result = (0, encodeNaN_1.encodeNaN)();\n                break;\n            }\n            if (val === Infinity || val === -Infinity) {\n                isRefAllowed = false;\n                result = (0, encodeInfinity_1.encodeInfinity)(val);\n                break;\n            }\n            break;\n        }\n        case 'string': {\n            isRefAllowed = val.length > 2;\n            result = (0, encodeString_1.encodeString)(val);\n            break;\n        }\n        case 'object': {\n            if (val === null) {\n                isRefAllowed = false;\n                result = (0, encodeNull_1.encodeNull)();\n                break;\n            }\n            if (Array.isArray(val)) {\n                isRefAllowed = true;\n                result = (0, encodeArray_1.encodeArray)(val, options);\n                break;\n            }\n            if ((0, isObject_1.isObject)(val)) {\n                isRefAllowed = true;\n                result = (0, encodeObject_1.encodeObject)(val, options);\n                break;\n            }\n            if ((0, isSet_1.isSet)(val)) {\n                isRefAllowed = true;\n                result = (0, encodeSet_1.encodeSet)(val, options);\n                break;\n            }\n            if ((0, isMap_1.isMap)(val)) {\n                isRefAllowed = true;\n                result = (0, encodeMap_1.encodeMap)(val, options);\n                break;\n            }\n            if ((0, isTypedArray_1.isTypedArray)(val)) {\n                isRefAllowed = true;\n                result = (0, encodeTypedArray_1.encodeTypedArray)(val, options);\n                break;\n            }\n            if (val instanceof Date) {\n                isRefAllowed = Math.abs(val.getTime()) > 255;\n                result = (0, encodeDate_1.encodeDate)(val, options);\n                break;\n            }\n            if ((0, isPrimitiveObjectWrapper_1.isPrimitiveObjectWrapper)(val)) {\n                isRefAllowed = true;\n                result = (0, encodePrimitiveObjectWrapper_1.encodePrimitiveObjectWrapper)(val, options);\n                break;\n            }\n            if ((0, isClassInstance_1.isClassInstance)(val)) {\n                isRefAllowed = true;\n                result = (0, encodeClassInstance_1.encodeClassInstance)(val, options);\n                break;\n            }\n            break;\n        }\n        case 'bigint': {\n            isRefAllowed = true;\n            result = (0, encodeBigInt_1.encodeBigInt)(val);\n            break;\n        }\n        case 'symbol': {\n            isRefAllowed = true;\n            result = (0, encodeSymbol_1.encodeSymbol)(val);\n            break;\n        }\n    }\n    if (result === null) {\n        throw new Error(`Unsupported encoding value: \"${val}\", type: \"${type}\"`);\n    }\n    if (refData) {\n        if (isRefAllowed) {\n            const refCopy = context.refCopy.get(result);\n            if (refCopy) {\n                if (!refData.encodedRefCopy) {\n                    refData.encodedRefCopy = (0, encodeRef_1.encodeRef)('copy', refCopy.refId, options);\n                }\n                return refData.encodedRefCopy;\n            }\n            else {\n                context.refCopy.set(result, refData);\n            }\n        }\n        else {\n            context.refMap.delete(val);\n        }\n    }\n    return result;\n};\nexports.encode = encode;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encode.ts?\n}")},4680:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeSet = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decode_1 = __webpack_require__(/*! ./decode */ 6842);\nconst decodeSet = (typeByte, stream, options, initSet = new Set()) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Set) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding set`);\n    }\n    const bytesCount = typeByte & 7;\n    if (bytesCount === 0) {\n        return initSet;\n    }\n    const count = (0, bytesToInteger_1.bytesToInteger)(stream.readBytes(bytesCount));\n    const set = initSet;\n    for (let i = 0; i < count; i += 1) {\n        const value = (0, decode_1.decode)(stream.readByte(), stream, options);\n        set.add(value);\n    }\n    return set;\n};\nexports.decodeSet = decodeSet;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeSet.ts?\n}')},5175:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodePrimitiveObjectWrapperStream = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeStream_1 = __webpack_require__(/*! ./decodeStream */ 7538);\nconst decodePrimitiveObjectWrapperStream = async (typeByte, stream, options) => {\n    if (typeByte !== (ETypeByteCode_1.ETypeByteCode.Instruction | 0)) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding primitive object wrapper`);\n    }\n    const value = await (0, decodeStream_1.decodeStream)(null, stream, options);\n    switch (typeof value) {\n        case 'string': return new String(value);\n        case 'boolean': return new Boolean(value);\n        case 'number': return new Number(value);\n    }\n    throw new Error(`Can not create Primitive Object Wrapper for value ${value}, type ${typeof value}`);\n};\nexports.decodePrimitiveObjectWrapperStream = decodePrimitiveObjectWrapperStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodePrimitiveObjectWrapperStream.ts?\n}")},5198:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeFloat = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeFloat = (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Float) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding float`);\n    }\n    const count = (typeByte & 7) + 1;\n    let map = 0;\n    if (typeByte & 8) {\n        // custom map\n        map = stream.readByte();\n    }\n    else {\n        for (let i = 0; i < count; i += 1) {\n            map = map | (1 << i);\n        }\n    }\n    const bytesCount = stream.readBytes(count);\n    const floatBytes = new Uint8Array(8);\n    let byteIndex = 0;\n    for (let i = 0; i < 8; i += 1) {\n        if (map & (128 >>> i)) {\n            floatBytes[i] = bytesCount[byteIndex];\n            byteIndex += 1;\n        }\n    }\n    const float = new Float64Array(floatBytes.buffer);\n    return float[0];\n};\nexports.decodeFloat = decodeFloat;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeFloat.ts?\n}')},5223:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDecodeOptions = void 0;\nconst createDecodeOptions = () => {\n    return {\n        context: {\n            refs: [],\n            refByteSlice: [],\n            readBytes: [],\n        },\n        objects: {\n            classInstanceConstructorNameKey: '__jsbtConstructorName',\n            factories: {}\n        }\n    };\n};\nexports.createDecodeOptions = createDecodeOptions;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/options/createDecodeOptions.ts?\n}")},5409:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ETypedArrayByteCode = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ./ETypeByteCode */ 6156);\nvar ETypedArrayByteCode;\n(function (ETypedArrayByteCode) {\n    ETypedArrayByteCode[ETypedArrayByteCode["ArrayBuffer"] = 96] = "ArrayBuffer";\n    ETypedArrayByteCode[ETypedArrayByteCode["Int8Array"] = 97] = "Int8Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["Uint8Array"] = 98] = "Uint8Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["Uint8ClampedArray"] = 99] = "Uint8ClampedArray";\n    ETypedArrayByteCode[ETypedArrayByteCode["Int16Array"] = 100] = "Int16Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["Uint16Array"] = 101] = "Uint16Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["Int32Array"] = 102] = "Int32Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["Uint32Array"] = 103] = "Uint32Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["Float32Array"] = 104] = "Float32Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["Float64Array"] = 105] = "Float64Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["BigInt64Array"] = 106] = "BigInt64Array";\n    ETypedArrayByteCode[ETypedArrayByteCode["BigUint64Array"] = 107] = "BigUint64Array";\n})(ETypedArrayByteCode || (exports.ETypedArrayByteCode = ETypedArrayByteCode = {}));\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/enums/ETypedArrayByteCode.ts?\n}')},5503:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeStringStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeStringStream = async (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.String) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding string`);\n    }\n    const count = typeByte & 7;\n    if (count === 0) {\n        return '';\n    }\n    const bytesCount = await stream.readStreamBytes(count);\n    const bytesLength = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    const decoder = new TextDecoder('utf-8');\n    const bytes = await stream.readStreamBytes(bytesLength);\n    return decoder.decode(bytes);\n};\nexports.decodeStringStream = decodeStringStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeStringStream.ts?\n}")},5560:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeBoolean = void 0;\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst TRUE_BYTE_CHR = (0, toChar_1.toChar)(EConstantByteCode_1.EConstantByteCode.TRUE);\nconst FALSE_BYTE_CHR = (0, toChar_1.toChar)(EConstantByteCode_1.EConstantByteCode.FALSE);\nconst encodeBoolean = (value) => {\n    if (typeof value !== \'boolean\') {\n        throw new Error(`Expecting "boolean" type, received "${value}" (${typeof value})`);\n    }\n    return value ? TRUE_BYTE_CHR : FALSE_BYTE_CHR;\n};\nexports.encodeBoolean = encodeBoolean;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeBoolean.ts?\n}')},5570:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeSymbolStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst bytesToUtf16_1 = __webpack_require__(/*! ../converter/bytesToUtf16 */ 632);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeSymbolStream = async (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Symbol) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding symbol`);\n    }\n    const count = typeByte & 7;\n    if (count === 0) {\n        return Symbol.for('');\n    }\n    const bytesCount = await stream.readStreamBytes(count);\n    const strLen = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    const bytes = await stream.readStreamBytes(strLen);\n    return Symbol.for((0, bytesToUtf16_1.bytesToUtf16)(bytes));\n};\nexports.decodeSymbolStream = decodeSymbolStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeSymbolStream.ts?\n}")},5761:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isClassInstance = void 0;\nconst isClassInstance = (value) => {\n    return (typeof value === 'object' &&\n        value &&\n        !Array.isArray(value) &&\n        value?.constructor?.name &&\n        value.constructor.name !== 'Object');\n};\nexports.isClassInstance = isClassInstance;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isClassInstance.ts?\n}")},5825:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.isPrimitiveObjectWrapper = void 0;\nconst isPrimitiveObjectWrapper = (value) => {\n    return value instanceof Number || value instanceof String || value instanceof Boolean;\n};\nexports.isPrimitiveObjectWrapper = isPrimitiveObjectWrapper;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isPrimitiveObjectWrapper.ts?\n}')},6113:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.doubleToBytes = void 0;\nconst doubleToBytes = (value, bigEndianOrder = false) => {\n    const buffer = new ArrayBuffer(8); // JS numbers are 8 bytes long, or 64 bits\n    const longNum = new Float64Array(buffer); // so equivalent to Float64\n    longNum[0] = value;\n    const bytes = Array.from(new Uint8Array(buffer));\n    return (bigEndianOrder ? bytes.reverse() : bytes);\n};\nexports.doubleToBytes = doubleToBytes;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/converter/doubleToBytes.ts?\n}')},6156:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ETypeByteCode = void 0;\nvar ETypeByteCode;\n(function (ETypeByteCode) {\n    ETypeByteCode[ETypeByteCode["Constant"] = 0] = "Constant";\n    ETypeByteCode[ETypeByteCode["String"] = 16] = "String";\n    ETypeByteCode[ETypeByteCode["Integer"] = 32] = "Integer";\n    ETypeByteCode[ETypeByteCode["Float"] = 48] = "Float";\n    ETypeByteCode[ETypeByteCode["BigInt"] = 64] = "BigInt";\n    ETypeByteCode[ETypeByteCode["Array"] = 80] = "Array";\n    ETypeByteCode[ETypeByteCode["Typed_Array"] = 96] = "Typed_Array";\n    ETypeByteCode[ETypeByteCode["Object"] = 112] = "Object";\n    ETypeByteCode[ETypeByteCode["Set"] = 128] = "Set";\n    ETypeByteCode[ETypeByteCode["Map"] = 144] = "Map";\n    ETypeByteCode[ETypeByteCode["Symbol"] = 160] = "Symbol";\n    ETypeByteCode[ETypeByteCode["Refs"] = 176] = "Refs";\n    ETypeByteCode[ETypeByteCode["Date"] = 192] = "Date";\n    ETypeByteCode[ETypeByteCode["Instruction"] = 240] = "Instruction";\n})(ETypeByteCode || (exports.ETypeByteCode = ETypeByteCode = {}));\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/enums/ETypeByteCode.ts?\n}')},6247:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeTypedArray = void 0;\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst isTypedArray_1 = __webpack_require__(/*! ../utils/vars/isTypedArray */ 2525);\nconst encodeInteger_1 = __webpack_require__(/*! ./encodeInteger */ 7450);\nconst getTypedArrayByteCount_1 = __webpack_require__(/*! ../utils/typedArrays/getTypedArrayByteCount */ 598);\nconst ETypedArrayByteCode_1 = __webpack_require__(/*! ../enums/ETypedArrayByteCode */ 5409);\nconst getFilledItemsCount_1 = __webpack_require__(/*! ../utils/typedArrays/getFilledItemsCount */ 8745);\nconst calculateByteCountVariants_1 = __webpack_require__(/*! ../utils/typedArrays/calculateByteCountVariants */ 531);\nconst TYPED_ARRAY_CHAR_BY_NAME = {\n    ArrayBuffer: ETypedArrayByteCode_1.ETypedArrayByteCode.ArrayBuffer,\n    Int8Array: ETypedArrayByteCode_1.ETypedArrayByteCode.Int8Array,\n    Uint8Array: ETypedArrayByteCode_1.ETypedArrayByteCode.Uint8Array,\n    Uint8ClampedArray: ETypedArrayByteCode_1.ETypedArrayByteCode.Uint8ClampedArray,\n    Int16Array: ETypedArrayByteCode_1.ETypedArrayByteCode.Int16Array,\n    Uint16Array: ETypedArrayByteCode_1.ETypedArrayByteCode.Uint16Array,\n    Int32Array: ETypedArrayByteCode_1.ETypedArrayByteCode.Int32Array,\n    Uint32Array: ETypedArrayByteCode_1.ETypedArrayByteCode.Uint32Array,\n    Float32Array: ETypedArrayByteCode_1.ETypedArrayByteCode.Float32Array,\n    Float64Array: ETypedArrayByteCode_1.ETypedArrayByteCode.Float64Array,\n    BigInt64Array: ETypedArrayByteCode_1.ETypedArrayByteCode.BigInt64Array,\n    BigUint64Array: ETypedArrayByteCode_1.ETypedArrayByteCode.BigUint64Array,\n};\nconst encodeTypedArray = (tarr, options) => {\n    if (!(0, isTypedArray_1.isTypedArray)(tarr)) {\n        throw new Error(`Expecting "typedArray" type, received "${tarr}" (${typeof tarr})`);\n    }\n    const name = tarr.constructor.name;\n    const typeCode = TYPED_ARRAY_CHAR_BY_NAME[name];\n    if (tarr.byteLength === 0) {\n        return (0, toChar_1.toChar)(typeCode, 0);\n    }\n    const arr = tarr instanceof ArrayBuffer ? new Uint8Array(tarr) : tarr;\n    // TODO: various size\n    const bytesPerElement = (0, getTypedArrayByteCount_1.getBytesPerElement)(tarr);\n    const definedItemsCount = (0, getFilledItemsCount_1.getFilledItemsCount)(tarr);\n    if (tarr.byteLength > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided typed array has too large length, limit ${constants_1.MAX_7_BYTES_INTEGER}, received ${tarr.byteLength}`);\n    }\n    const msg = [];\n    const calculation = (0, calculateByteCountVariants_1.calculateByteCountVariants)(tarr);\n    const isValueEncoding = calculation.envValueSize <= calculation.encKeyValueSize;\n    // type byte\n    msg.push((0, toChar_1.toChar)(typeCode));\n    // rsv / endoding / length / items count\n    const byteLenBytes = (0, integerToBytes_1.integerToBytes)(tarr.byteLength);\n    const lenBytes = (0, integerToBytes_1.integerToBytes)(arr.length);\n    const defCountBytes = (0, integerToBytes_1.integerToBytes)(definedItemsCount);\n    msg.push((0, toChar_1.toChar)(0 |\n        (isValueEncoding ? 0 : 64) |\n        (isValueEncoding ? 0 : (7 & byteLenBytes.length) << 3) |\n        (isValueEncoding ? (7 & lenBytes.length) : (7 & defCountBytes.length))));\n    if (isValueEncoding) {\n        // items count\n        msg.push((0, toChar_1.toChar)(...lenBytes));\n        const uint8arr = new Uint8Array(tarr instanceof ArrayBuffer ? tarr : tarr.buffer);\n        msg.push((0, toChar_1.toChar)(...uint8arr));\n    }\n    else {\n        // length\n        msg.push((0, toChar_1.toChar)(...byteLenBytes));\n        msg.push((0, toChar_1.toChar)(...defCountBytes));\n        for (let i = 0; i < arr.length; i += 1) {\n            const num = arr[i];\n            if (num) {\n                const uint8arr = new Uint8Array(arr.buffer, i * bytesPerElement, bytesPerElement);\n                msg.push((0, encodeInteger_1.encodeInteger)(i));\n                msg.push((0, toChar_1.toChar)(...uint8arr));\n            }\n        }\n    }\n    return msg.join(\'\');\n};\nexports.encodeTypedArray = encodeTypedArray;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeTypedArray.ts?\n}')},6268:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.bytesToInteger = void 0;\nconst bytesToInteger = (bytes) => {\n    const len = Array.isArray(bytes) ? bytes.length : bytes.byteLength;\n    if (len === 0) {\n        return 0;\n    }\n    let int = 0;\n    for (let i = 0; i < len; i += 1) {\n        const byte = bytes[i];\n        int = (byte * (256 ** i)) + int;\n    }\n    return int;\n};\nexports.bytesToInteger = bytesToInteger;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/converter/bytesToInteger.ts?\n}')},6475:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeClassInstance = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst encode_1 = __webpack_require__(/*! ./encode */ 4650);\nconst isClassInstance_1 = __webpack_require__(/*! ../utils/vars/isClassInstance */ 5761);\nconst encodeClassInstance = (obj, options) => {\n    if (!(0, isClassInstance_1.isClassInstance)(obj)) {\n        throw new Error(`Expecting \"object\" type, received \"${obj}\" (${typeof obj})`);\n    }\n    const props = typeof obj?.toJSBT === 'function'\n        ? obj.toJSBT()\n        : typeof obj?.toJSON === 'function'\n            ? obj.toJSON()\n            : obj.valueOf();\n    const msgBody = [];\n    let count = 0;\n    // constructor name\n    const constructorNameKey = options.objects.classInstanceConstructorNameKey;\n    const constructorName = (constructorNameKey && (props[constructorNameKey] || obj[constructorNameKey])) || obj?.constructor?.name || '';\n    msgBody.push((0, encode_1.encode)(constructorName, options));\n    for (const key in props) {\n        if (!props.hasOwnProperty(key)) {\n            continue;\n        }\n        msgBody.push((0, encode_1.encode)(key, options));\n        msgBody.push((0, encode_1.encode)(props[key], options));\n        count += 1;\n    }\n    for (const sym of Object.getOwnPropertySymbols(props)) {\n        msgBody.push((0, encode_1.encode)(sym, options));\n        msgBody.push((0, encode_1.encode)(props[sym], options));\n        count += 1;\n    }\n    if (count > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided object has too many props, limit ${constants_1.MAX_7_BYTES_INTEGER}, received ${count}`);\n    }\n    const msgHeaders = [];\n    const countBytes = (0, integerToBytes_1.integerToBytes)(count);\n    // type byte\n    msgHeaders.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Object |\n        8 | // Class Instance\n        (7 & countBytes.length)));\n    // length\n    msgHeaders.push((0, toChar_1.toChar)(...countBytes));\n    return msgHeaders.join('') + msgBody.join('');\n};\nexports.encodeClassInstance = encodeClassInstance;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeClassInstance.ts?\n}")},6537:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeObject = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst isObject_1 = __webpack_require__(/*! ../utils/vars/isObject */ 9231);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst encode_1 = __webpack_require__(/*! ./encode */ 4650);\nconst EMPTY_OBJECT_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Object & 240);\nconst encodeObject = (obj, options) => {\n    if (!(0, isObject_1.isObject)(obj)) {\n        throw new Error(`Expecting "object" type, received "${obj}" (${typeof obj})`);\n    }\n    const msgBody = [];\n    let count = 0;\n    for (const key in obj) {\n        if (!obj.hasOwnProperty(key)) {\n            continue;\n        }\n        msgBody.push((0, encode_1.encode)(key, options));\n        msgBody.push((0, encode_1.encode)(obj[key], options));\n        count += 1;\n    }\n    for (const sym of Object.getOwnPropertySymbols(obj)) {\n        msgBody.push((0, encode_1.encode)(sym, options));\n        msgBody.push((0, encode_1.encode)(obj[sym], options));\n        count += 1;\n    }\n    if (count === 0) {\n        return EMPTY_OBJECT_BYTE_CHAR;\n    }\n    if (count > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided object has too many props, limit ${constants_1.MAX_7_BYTES_INTEGER}, received ${count}`);\n    }\n    const msgHeaders = [];\n    const countBytes = (0, integerToBytes_1.integerToBytes)(count);\n    // type byte\n    msgHeaders.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Object\n        | (7 & countBytes.length)));\n    // length\n    msgHeaders.push((0, toChar_1.toChar)(...countBytes));\n    return msgHeaders.join(\'\') + msgBody.join(\'\');\n};\nexports.encodeObject = encodeObject;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeObject.ts?\n}')},6766:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeDate = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst ZERO_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Date & 240);\nconst encodeDate = (value, options) => {\n    if (!(value instanceof Date)) {\n        throw new Error(`Expecting "Date" type, received "${value}" (${typeof value})`);\n    }\n    const ms = value.getTime();\n    if (Math.abs(ms) > constants_1.MAX_DATE_INTEGER) {\n        throw new Error(`Can not encode invalid date`);\n    }\n    if (ms === 0) {\n        return ZERO_BYTE_CHAR;\n    }\n    const msg = [];\n    const val = Math.abs(ms);\n    const isPositive = ms > 0;\n    const bytes = (0, integerToBytes_1.integerToBytes)(val);\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Date | ((7 & bytes.length) | (isPositive ? 0 : 8))));\n    // encode bytes\n    msg.push((0, toChar_1.toChar)(...bytes));\n    return msg.join(\'\');\n};\nexports.encodeDate = encodeDate;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeDate.ts?\n}')},6810:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeSymbol = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst bytesToUtf16_1 = __webpack_require__(/*! ../converter/bytesToUtf16 */ 632);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeSymbol = (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Symbol) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding symbol`);\n    }\n    const count = typeByte & 7;\n    if (count === 0) {\n        return Symbol.for('');\n    }\n    const bytesCount = stream.readBytes(count);\n    const strLen = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    const bytes = stream.readBytes(strLen);\n    return Symbol.for((0, bytesToUtf16_1.bytesToUtf16)(bytes));\n};\nexports.decodeSymbol = decodeSymbol;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeSymbol.ts?\n}")},6815:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeString = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeString = (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.String) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding string`);\n    }\n    const count = typeByte & 7;\n    if (count === 0) {\n        return '';\n    }\n    const bytesCount = stream.readBytes(count);\n    const bytesLength = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    const decoder = new TextDecoder('utf-8');\n    const bytes = stream.readBytes(bytesLength);\n    return decoder.decode(bytes);\n};\nexports.decodeString = decodeString;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeString.ts?\n}")},6842:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decode = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeArray_1 = __webpack_require__(/*! ./decodeArray */ 137);\nconst decodeBigInt_1 = __webpack_require__(/*! ./decodeBigInt */ 3461);\nconst decodeConstant_1 = __webpack_require__(/*! ./decodeConstant */ 8494);\nconst decodeDate_1 = __webpack_require__(/*! ./decodeDate */ 4382);\nconst decodeFloat_1 = __webpack_require__(/*! ./decodeFloat */ 5198);\nconst decodeInteger_1 = __webpack_require__(/*! ./decodeInteger */ 2186);\nconst decodeMap_1 = __webpack_require__(/*! ./decodeMap */ 1690);\nconst decodeObject_1 = __webpack_require__(/*! ./decodeObject */ 1417);\nconst decodePrimitiveObjectWrapper_1 = __webpack_require__(/*! ./decodePrimitiveObjectWrapper */ 2519);\nconst decodeRef_1 = __webpack_require__(/*! ./decodeRef */ 2157);\nconst decodeSet_1 = __webpack_require__(/*! ./decodeSet */ 4680);\nconst decodeString_1 = __webpack_require__(/*! ./decodeString */ 6815);\nconst decodeSymbol_1 = __webpack_require__(/*! ./decodeSymbol */ 6810);\nconst decodeTypedArray_1 = __webpack_require__(/*! ./decodeTypedArray */ 3815);\nconst decode = (typeByte, stream, options) => {\n    const { refs, refByteSlice } = options.context;\n    if (typeByte === null) {\n        typeByte = stream.readByte();\n    }\n    const type = typeByte & 240;\n    const isRefEnabled = !(type === ETypeByteCode_1.ETypeByteCode.Refs);\n    const refId = refs.length;\n    let isRefAllowed = true;\n    if (isRefEnabled) {\n        refs.push(undefined); // keep place\n        refByteSlice.push({\n            index: stream.getReadBytesIndex() - 1,\n            length: 0,\n        });\n    }\n    let result;\n    let isResultReceived = false;\n    switch (type) {\n        case ETypeByteCode_1.ETypeByteCode.Refs: {\n            result = (0, decodeRef_1.decodeRef)(typeByte, stream, options);\n            isResultReceived = true;\n            isRefAllowed = false;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Constant: {\n            result = (0, decodeConstant_1.decodeConstant)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = false;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.String: {\n            result = (0, decodeString_1.decodeString)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = result.length > 2;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Integer: {\n            result = (0, decodeInteger_1.decodeInteger)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = result > 255 || result < -255;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Float: {\n            result = (0, decodeFloat_1.decodeFloat)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.BigInt: {\n            result = (0, decodeBigInt_1.decodeBigInt)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Array: {\n            result = (0, decodeArray_1.decodeArray)(typeByte, stream, options, (refs[refId] = []));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Typed_Array: {\n            result = (0, decodeTypedArray_1.decodeTypedArray)(typeByte, stream, options);\n            isResultReceived = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Object: {\n            result = (0, decodeObject_1.decodeObject)(typeByte, stream, options, (refs[refId] = {}));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Set: {\n            result = (0, decodeSet_1.decodeSet)(typeByte, stream, options, (refs[refId] = new Set()));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Map: {\n            result = (0, decodeMap_1.decodeMap)(typeByte, stream, options, (refs[refId] = new Map()));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Symbol: {\n            result = (0, decodeSymbol_1.decodeSymbol)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Date: {\n            result = (0, decodeDate_1.decodeDate)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = Math.abs(result.getTime()) > 255;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Instruction: {\n            switch (typeByte) {\n                case (ETypeByteCode_1.ETypeByteCode.Instruction | 240): {\n                    // Primitive Object Wrapper\n                    result = (0, decodePrimitiveObjectWrapper_1.decodePrimitiveObjectWrapper)(typeByte, stream, options);\n                    isResultReceived = true;\n                    isRefAllowed = true;\n                    break;\n                }\n                default: {\n                    throw new Error(`Not supported instruction ${typeByte}`);\n                }\n            }\n            break;\n        }\n    }\n    if (isResultReceived === false) {\n        throw new Error(`Unsupported decoding value: "${typeByte}"`);\n    }\n    if (isRefEnabled) {\n        if (isRefAllowed) {\n            refs[refId] = result;\n            refByteSlice[refId].length = stream.getReadBytesIndex() - refByteSlice[refId].index;\n        }\n        else {\n            refs.pop();\n            refByteSlice.pop();\n        }\n    }\n    return result;\n};\nexports.decode = decode;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decode.ts?\n}')},7042:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeMapStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeStream_1 = __webpack_require__(/*! ./decodeStream */ 7538);\nconst decodeMapStream = async (typeByte, stream, options, initMap = new Map()) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Map) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding map`);\n    }\n    const bytesCount = typeByte & 7;\n    if (bytesCount === 0) {\n        return initMap;\n    }\n    const count = (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(bytesCount));\n    const map = initMap;\n    for (let i = 0; i < count; i += 1) {\n        const key = await (0, decodeStream_1.decodeStream)(await stream.readStreamByte(), stream, options);\n        const value = await (0, decodeStream_1.decodeStream)(await stream.readStreamByte(), stream, options);\n        map.set(key, value);\n    }\n    return map;\n};\nexports.decodeMapStream = decodeMapStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeMapStream.ts?\n}')},7344:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeUndefined = void 0;\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst UNDEFINED_BYTE = (0, toChar_1.toChar)(EConstantByteCode_1.EConstantByteCode.Undefined);\nconst encodeUndefined = () => {\n    return UNDEFINED_BYTE;\n};\nexports.encodeUndefined = encodeUndefined;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeUndefined.ts?\n}')},7450:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encodeInteger = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst constants_1 = __webpack_require__(/*! ../constants */ 2640);\nconst integerToBytes_1 = __webpack_require__(/*! ../converter/integerToBytes */ 9670);\nconst toChar_1 = __webpack_require__(/*! ../utils/toChar */ 8782);\nconst isInteger_1 = __webpack_require__(/*! ../utils/vars/isInteger */ 64);\nconst POS_ZERO_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Integer & 240);\nconst NEG_ZERO_BYTE_CHAR = (0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Integer & 240 | 8);\nconst encodeInteger = (value) => {\n    if (!(0, isInteger_1.isInteger)(value)) {\n        throw new Error(`Expecting "integer" type, received "${value}" (${typeof value})`);\n    }\n    if (Math.abs(value) > constants_1.MAX_7_BYTES_INTEGER) {\n        throw new Error(`Can not encode unsafe integer`);\n    }\n    if (value === 0) {\n        return Object.is(value, 0) ? POS_ZERO_BYTE_CHAR : NEG_ZERO_BYTE_CHAR;\n    }\n    const msg = [];\n    const val = Math.abs(value);\n    const isPositive = value > 0;\n    const bytes = (0, integerToBytes_1.integerToBytes)(val);\n    // type byte\n    msg.push((0, toChar_1.toChar)(ETypeByteCode_1.ETypeByteCode.Integer | ((7 & bytes.length) | (isPositive ? 0 : 8))));\n    // encode bytes\n    msg.push((0, toChar_1.toChar)(...bytes));\n    return msg.join(\'\');\n};\nexports.encodeInteger = encodeInteger;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/encoder/encodeInteger.ts?\n}')},7538:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeStream = void 0;\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeArrayStream_1 = __webpack_require__(/*! ./decodeArrayStream */ 1625);\nconst decodeBigIntStream_1 = __webpack_require__(/*! ./decodeBigIntStream */ 125);\nconst decodeConstantStream_1 = __webpack_require__(/*! ./decodeConstantStream */ 1550);\nconst decodeDateStream_1 = __webpack_require__(/*! ./decodeDateStream */ 9278);\nconst decodeFloatStream_1 = __webpack_require__(/*! ./decodeFloatStream */ 2862);\nconst decodeIntegerStream_1 = __webpack_require__(/*! ./decodeIntegerStream */ 9330);\nconst decodeMapStream_1 = __webpack_require__(/*! ./decodeMapStream */ 7042);\nconst decodeObjectStream_1 = __webpack_require__(/*! ./decodeObjectStream */ 8489);\nconst decodePrimitiveObjectWrapperStream_1 = __webpack_require__(/*! ./decodePrimitiveObjectWrapperStream */ 5175);\nconst decodeRefStream_1 = __webpack_require__(/*! ./decodeRefStream */ 2037);\nconst decodeSetStream_1 = __webpack_require__(/*! ./decodeSetStream */ 320);\nconst decodeStringStream_1 = __webpack_require__(/*! ./decodeStringStream */ 5503);\nconst decodeSymbolStream_1 = __webpack_require__(/*! ./decodeSymbolStream */ 5570);\nconst decodeTypedArrayStream_1 = __webpack_require__(/*! ./decodeTypedArrayStream */ 9159);\nconst decodeStream = async (typeByte, stream, options) => {\n    const { refs, refByteSlice } = options.context;\n    if (typeByte === null) {\n        typeByte = await stream.readStreamByte();\n    }\n    const type = typeByte & 240;\n    const isRefEnabled = !(type === ETypeByteCode_1.ETypeByteCode.Refs);\n    const refId = refs.length;\n    let isRefAllowed = true;\n    if (isRefEnabled) {\n        refs.push(undefined); // keep place\n        refByteSlice.push({\n            index: stream.getReadBytesIndex() - 1,\n            length: 0,\n        });\n    }\n    let result;\n    let isResultReceived = false;\n    switch (type) {\n        case ETypeByteCode_1.ETypeByteCode.Refs: {\n            result = await (0, decodeRefStream_1.decodeRefStream)(typeByte, stream, options);\n            isResultReceived = true;\n            isRefAllowed = false;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Constant: {\n            result = await (0, decodeConstantStream_1.decodeConstantStream)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = false;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.String: {\n            result = await (0, decodeStringStream_1.decodeStringStream)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = result.length > 2;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Integer: {\n            result = await (0, decodeIntegerStream_1.decodeIntegerStream)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = result > 255 || result < -255;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Float: {\n            result = await (0, decodeFloatStream_1.decodeFloatStream)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.BigInt: {\n            result = await (0, decodeBigIntStream_1.decodeBigIntStream)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Array: {\n            result = await (0, decodeArrayStream_1.decodeArrayStream)(typeByte, stream, options, (refs[refId] = []));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Typed_Array: {\n            result = await (0, decodeTypedArrayStream_1.decodeTypedArrayStream)(typeByte, stream, options);\n            isResultReceived = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Object: {\n            result = await (0, decodeObjectStream_1.decodeObjectStream)(typeByte, stream, options, (refs[refId] = {}));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Set: {\n            result = await (0, decodeSetStream_1.decodeSetStream)(typeByte, stream, options, (refs[refId] = new Set()));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Map: {\n            result = await (0, decodeMapStream_1.decodeMapStream)(typeByte, stream, options, (refs[refId] = new Map()));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Symbol: {\n            result = await (0, decodeSymbolStream_1.decodeSymbolStream)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Date: {\n            result = await (0, decodeDateStream_1.decodeDateStream)(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = Math.abs(result.getTime()) > 255;\n            break;\n        }\n        case ETypeByteCode_1.ETypeByteCode.Instruction: {\n            switch (typeByte) {\n                case (ETypeByteCode_1.ETypeByteCode.Instruction | 240): {\n                    // Primitive Object Wrapper\n                    result = await (0, decodePrimitiveObjectWrapperStream_1.decodePrimitiveObjectWrapperStream)(typeByte, stream, options);\n                    isResultReceived = true;\n                    isRefAllowed = true;\n                    break;\n                }\n                default: {\n                    throw new Error(`Not supported instruction ${typeByte}`);\n                }\n            }\n            break;\n        }\n    }\n    if (isResultReceived === false) {\n        throw new Error(`Unsupported decoding value: "${typeByte}"`);\n    }\n    if (isRefEnabled) {\n        if (isRefAllowed) {\n            refs[refId] = result;\n            refByteSlice[refId].length = stream.getReadBytesIndex() - refByteSlice[refId].index;\n        }\n        else {\n            refs.pop();\n            refByteSlice.pop();\n        }\n    }\n    return result;\n};\nexports.decodeStream = decodeStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeStream.ts?\n}')},7729:function(__unused_webpack_module,exports,__webpack_require__){eval('{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.JSBT = exports.ByteStream = void 0;\nvar ByteStream_1 = __webpack_require__(/*! ./reader/ByteStream */ 2043);\nObject.defineProperty(exports, "ByteStream", ({ enumerable: true, get: function () { return __importDefault(ByteStream_1).default; } }));\nvar JSBT_1 = __webpack_require__(/*! ./JSBT */ 7972);\nObject.defineProperty(exports, "JSBT", ({ enumerable: true, get: function () { return JSBT_1.JSBT; } }));\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/index.ts?\n}')},7972:function(__unused_webpack_module,exports,__webpack_require__){eval('{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.JSBT = void 0;\nconst decode_1 = __webpack_require__(/*! ./decoder/decode */ 6842);\nconst decodeStream_1 = __webpack_require__(/*! ./decoder/decodeStream */ 7538);\nconst createDecodeOptions_1 = __webpack_require__(/*! ./decoder/options/createDecodeOptions */ 5223);\nconst encode_1 = __webpack_require__(/*! ./encoder/encode */ 4650);\nconst createEncodeOptions_1 = __webpack_require__(/*! ./encoder/options/createEncodeOptions */ 507);\nconst ByteStream_1 = __importDefault(__webpack_require__(/*! ./reader/ByteStream */ 2043));\nclass JSBT {\n    static setClassFactories(factories) {\n        this._classFactories = factories;\n    }\n    static encode(value) {\n        const options = (0, createEncodeOptions_1.createEncodeOptions)();\n        options.refs = {\n            enabled: true,\n        };\n        const result = (0, encode_1.encode)(value, options);\n        return result;\n    }\n    static decode(value) {\n        const stream = new ByteStream_1.default(value);\n        stream.completeStream();\n        const options = (0, createDecodeOptions_1.createDecodeOptions)();\n        options.objects.factories = this._classFactories;\n        options.context.readBytes = stream.getReadBytes();\n        const result = (0, decode_1.decode)(null, stream, options);\n        return result;\n    }\n    static async decodeStream(stream) {\n        const options = (0, createDecodeOptions_1.createDecodeOptions)();\n        options.objects.factories = this._classFactories;\n        options.context.readBytes = stream.getReadBytes();\n        const result = (0, decodeStream_1.decodeStream)(null, stream, options);\n        return result;\n    }\n}\nexports.JSBT = JSBT;\nJSBT._classFactories = {};\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/JSBT.ts?\n}')},8489:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeObjectStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeStream_1 = __webpack_require__(/*! ./decodeStream */ 7538);\nconst decodeObjectStream = async (typeByte, stream, options, initObj = {}) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Object) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding object`);\n    }\n    const bytesCount = typeByte & 7;\n    if (bytesCount === 0) {\n        return initObj;\n    }\n    const count = (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(bytesCount));\n    const isClassInstance = Boolean(typeByte & 8);\n    const constructorName = isClassInstance ? await (0, decodeStream_1.decodeStream)(null, stream, options) : null;\n    const obj = initObj;\n    for (let i = 0; i < count; i += 1) {\n        const key = await (0, decodeStream_1.decodeStream)(null, stream, options);\n        const value = await (0, decodeStream_1.decodeStream)(null, stream, options);\n        obj[key] = value;\n    }\n    if (isClassInstance) {\n        const constructorNameKey = options.objects.classInstanceConstructorNameKey;\n        if (constructorNameKey !== null) {\n            const classConstructor = options.objects.factories[constructorName];\n            if (classConstructor) {\n                Object.setPrototypeOf(obj, classConstructor.prototype);\n            }\n            else {\n                Object.defineProperty(obj, constructorNameKey, {\n                    value: constructorName,\n                    configurable: true,\n                    enumerable: false,\n                    writable: false,\n                });\n            }\n        }\n    }\n    return obj;\n};\nexports.decodeObjectStream = decodeObjectStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeObjectStream.ts?\n}')},8494:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeConstant = exports.constantMap = void 0;\nconst EConstantByteCode_1 = __webpack_require__(/*! ../enums/EConstantByteCode */ 4556);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nexports.constantMap = new Map([\n    [EConstantByteCode_1.EConstantByteCode.FALSE, false],\n    [EConstantByteCode_1.EConstantByteCode.TRUE, true],\n    [EConstantByteCode_1.EConstantByteCode.Null, null],\n    [EConstantByteCode_1.EConstantByteCode.Undefined, undefined],\n    [EConstantByteCode_1.EConstantByteCode.NaN, NaN],\n    [EConstantByteCode_1.EConstantByteCode.Pos_Infinity, +Infinity],\n    [EConstantByteCode_1.EConstantByteCode.Neg_Infinity, -Infinity],\n    [EConstantByteCode_1.EConstantByteCode.Empty_Value, ''],\n]);\nconst decodeConstant = (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Constant) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding contant`);\n    }\n    if (!exports.constantMap.has(typeByte)) {\n        throw new Error('Not supported contsant for decoding');\n    }\n    return exports.constantMap.get(typeByte);\n};\nexports.decodeConstant = decodeConstant;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeConstant.ts?\n}")},8745:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getFilledItemsCount = void 0;\nconst getFilledItemsCount = (arr) => {\n    let count = 0;\n    const tarr = (arr instanceof ArrayBuffer) ? new Uint8Array(arr) : arr;\n    tarr.forEach((item) => {\n        if (item !== 0) {\n            count += 1;\n        }\n    });\n    return count;\n};\nexports.getFilledItemsCount = getFilledItemsCount;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/typedArrays/getFilledItemsCount.ts?\n}')},8782:(__unused_webpack_module,exports)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.toChar = void 0;\nconst toChar = (...codes) => {\n    return String.fromCharCode(...codes);\n};\nexports.toChar = toChar;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/toChar.ts?\n}')},9159:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeTypedArrayStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst ETypedArrayByteCode_1 = __webpack_require__(/*! ../enums/ETypedArrayByteCode */ 5409);\nconst getTypedArrayByteCount_1 = __webpack_require__(/*! ../utils/typedArrays/getTypedArrayByteCount */ 598);\nconst decodeIntegerStream_1 = __webpack_require__(/*! ./decodeIntegerStream */ 9330);\nconst decodeTypedArray_1 = __webpack_require__(/*! ./decodeTypedArray */ 3815);\nconst decodeTypedArrayStream = async (typeByte, stream, options) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Typed_Array) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding typed array`);\n    }\n    const secondByte = await stream.readStreamByte();\n    const isKeyValueEncoding = secondByte & 64;\n    const itemsBytesCount = secondByte & 7;\n    const lengthBytesCount = (secondByte & 56) >>> 3;\n    const TypedArrayConstructor = decodeTypedArray_1.typedArrayConstructorByType[typeByte];\n    const tarr0 = new TypedArrayConstructor(0);\n    const bytesPerElement = (0, getTypedArrayByteCount_1.getBytesPerElement)(tarr0);\n    const len = isKeyValueEncoding\n        ? (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(lengthBytesCount))\n        : (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(itemsBytesCount));\n    const count = isKeyValueEncoding ? (0, bytesToInteger_1.bytesToInteger)(await stream.readStreamBytes(itemsBytesCount)) : len;\n    const dataGetterName = decodeTypedArray_1.dataViewGetter[typeByte];\n    if (isKeyValueEncoding) {\n        const tarr = new TypedArrayConstructor(Math.round(len / bytesPerElement));\n        for (let i = 0; i < count; i += 1) {\n            const key = await (0, decodeIntegerStream_1.decodeIntegerStream)(await stream.readStreamByte(), stream);\n            const valueBytes = await stream.readStreamBytes(bytesPerElement);\n            const view = new DataView(valueBytes.buffer);\n            tarr[key] = view[dataGetterName](0, true);\n        }\n        if (typeByte === ETypedArrayByteCode_1.ETypedArrayByteCode.ArrayBuffer) {\n            return tarr.buffer;\n        }\n        return tarr;\n    }\n    else {\n        const tarr = new TypedArrayConstructor(len);\n        const view = new DataView((await stream.readStreamBytes(bytesPerElement * len)).buffer);\n        for (let i = 0; i < len; i += 1) {\n            tarr[i] = view[dataGetterName](i * bytesPerElement, true);\n        }\n        if (typeByte === ETypedArrayByteCode_1.ETypedArrayByteCode.ArrayBuffer) {\n            return tarr.buffer;\n        }\n        return tarr;\n    }\n};\nexports.decodeTypedArrayStream = decodeTypedArrayStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeTypedArrayStream.ts?\n}')},9231:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isObject = void 0;\nconst isObject = (value) => {\n    return typeof value === 'object' && value && !Array.isArray(value) && value?.constructor?.name === 'Object';\n};\nexports.isObject = isObject;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/utils/vars/isObject.ts?\n}")},9278:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeDateStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeDateStream = async (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Date) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding Date`);\n    }\n    const count = typeByte & 7;\n    const isNegative = Boolean(typeByte & 8);\n    if (count === 0) {\n        return new Date(0);\n    }\n    const bytesCount = await stream.readStreamBytes(count);\n    const int = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    return new Date(isNegative ? -int : int);\n};\nexports.decodeDateStream = decodeDateStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeDateStream.ts?\n}')},9330:(__unused_webpack_module,exports,__webpack_require__)=>{eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decodeIntegerStream = void 0;\nconst bytesToInteger_1 = __webpack_require__(/*! ../converter/bytesToInteger */ 6268);\nconst ETypeByteCode_1 = __webpack_require__(/*! ../enums/ETypeByteCode */ 6156);\nconst decodeIntegerStream = async (typeByte, stream) => {\n    if ((typeByte & 240) !== ETypeByteCode_1.ETypeByteCode.Integer) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding integer`);\n    }\n    const count = typeByte & 7;\n    const isNegative = Boolean(typeByte & 8);\n    if (count === 0) {\n        return isNegative ? -0 : 0;\n    }\n    const bytesCount = await stream.readStreamBytes(count);\n    const int = (0, bytesToInteger_1.bytesToInteger)(bytesCount);\n    return isNegative ? -int : int;\n};\nexports.decodeIntegerStream = decodeIntegerStream;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/decoder/decodeIntegerStream.ts?\n}')},9670:(__unused_webpack_module,exports)=>{eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.integerToBytes = void 0;\nconst integerToBytes = (int, byteSize = 0, bigEndianOrder = false) => {\n    if (int < 0) {\n        throw new Error('integerToBytes does not support negative integers');\n    }\n    const bytes = [];\n    let num = Math.abs(int);\n    for (let i = 1; byteSize ? i <= byteSize : num; i += 1) {\n        const n = num % 256;\n        bytes.push(n);\n        num = num - n;\n        num = Math.floor(num / 256);\n    }\n    return bigEndianOrder ? bytes.reverse() : bytes;\n};\nexports.integerToBytes = integerToBytes;\n\n\n//# sourceURL=webpack://@cheprasov/jsbt/./src/converter/integerToBytes.ts?\n}")}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__webpack_require__),n.exports}var __webpack_exports__=__webpack_require__(7729);module.exports=__webpack_exports__})();