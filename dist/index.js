var C=class{constructor(r=[]){this._msgArrIndex=0;this._msgChrIndex=0;this._restByte=0;this._isStreamComplete=!1;this._isEOF=!1;this._waitingPromise=null;this._waitingPromiseResolver=null;this._waitingRejectTimeout=null;this._readBytes=[];this._msg=Array.isArray(r)?[...r]:[r]}getReadBytesIndex(){return this._readBytes.length}getReadBytes(){return this._readBytes}addMessage(r){Array.isArray(r)?this._msg.push(...r):this._msg.push(r),this._waitingPromise&&this._waitingPromiseResolver&&this._waitingPromiseResolver()}completeStream(r=[]){this.addMessage(r),this._isStreamComplete=!0}isCompleteMessage(){return this._isStreamComplete}isEOF(){return this._isEOF}waitMessages(r){if(this._waitingPromise)return this._waitingPromise;if(this._isStreamComplete)return Promise.reject("Can not wait completed stream");let o=new Promise((t,n)=>{this._waitingPromiseResolver=t,this._waitingRejectTimeout=setTimeout(()=>{n(`Waiting timeout ${r}ms is riched`)},r)}).finally(()=>{this._waitingRejectTimeout&&(clearTimeout(this._waitingRejectTimeout),this._waitingRejectTimeout=null),this._waitingPromise=null,this._waitingPromiseResolver=null});return this._waitingPromise=o,o}async readStreamBytes(r=1,o=3e4){let t=new Uint8Array(r),n=0;for(;n<r;){if(this._restByte){t[n]=this._restByte,this._readBytes.push(this._restByte),this._restByte=0,n+=1;continue}if(!(this._msgArrIndex in this._msg)){if(!this._isStreamComplete){await this.waitMessages(o);continue}throw this._isEOF=!0,new Error(`Can not read ${r-n} bytes`)}let i=NaN,c=this._msg[this._msgArrIndex];if(typeof c=="number"?(i=c,this._msgChrIndex=0,delete this._msg[this._msgArrIndex],this._msgArrIndex+=1):(i=c.charCodeAt(this._msgChrIndex),i>255&&(this._restByte=(i&65280)>>>8,i=i&255),this._msgChrIndex+=1),Number.isNaN(i)){delete this._msg[this._msgArrIndex],this._msgArrIndex+=1,this._msgChrIndex=0;continue}t[n]=i,this._readBytes.push(i),n+=1}return t}async readStreamByte(){return(await this.readStreamBytes(1))[0]}readBytes(r=1){if(!this._isStreamComplete)throw new Error("Sync bytes read is allowed only for completed stream");let o=new Uint8Array(r),t=0;for(;t<r;){if(this._restByte){o[t]=this._restByte,this._readBytes.push(this._restByte),this._restByte=0,t+=1;continue}if(!(this._msgArrIndex in this._msg))throw this._isEOF=!0,new Error(`Can not read ${r-t} bytes`);let n=NaN,i=this._msg[this._msgArrIndex];if(typeof i=="number"?(n=i,this._msgChrIndex=0,delete this._msg[this._msgArrIndex],this._msgArrIndex+=1):(n=i.charCodeAt(this._msgChrIndex),n>255&&(this._restByte=(n&65280)>>>8,n=n&255),this._msgChrIndex+=1),Number.isNaN(n)){delete this._msg[this._msgArrIndex],this._msgArrIndex+=1,this._msgChrIndex=0;continue}o[t]=n,this._readBytes.push(n),t+=1}return o}readByte(){return this.readBytes(1)[0]}};var p=e=>{let r=Array.isArray(e)?e.length:e.byteLength;if(r===0)return 0;let o=0;for(let t=0;t<r;t+=1)o=e[t]*256**t+o;return o};var h=(s=>(s[s.FALSE=0]="FALSE",s[s.TRUE=1]="TRUE",s[s.Null=2]="Null",s[s.Undefined=3]="Undefined",s[s.NaN=4]="NaN",s[s.Pos_Infinity=5]="Pos_Infinity",s[s.Neg_Infinity=6]="Neg_Infinity",s[s.Empty_Value=7]="Empty_Value",s))(h||{});var R=(e,r)=>{if((e&240)!==32)throw new Error(`Provaded incorrect type ${e} for decoding integer`);let o=e&7,t=!!(e&8);if(o===0)return t?-0:0;let n=r.readBytes(o),i=p(n);return t?-i:i};var J=(e,r,o,t=[])=>{if((e&240)!==80)throw new Error(`Provaded incorrect type ${e} for decoding array`);let n=e&8,i=e&7;if(i===0)return t;let c=p(r.readBytes(i)),m=n?p(r.readBytes(i)):c,s=t;if(s.length=c,n)for(let a=0;a<m;a+=1){let f=R(r.readByte(),r),l=A(r.readByte(),r,o);s[f]=l}else for(let a=0;a<c;a+=1){let f=r.readByte();if(f===h.Empty_Value)continue;let l=A(f,r,o);s[a]=l}return s};var F=e=>{let r=Array.isArray(e)?e.length:e.byteLength;if(r===0)return 0n;let o=0n;for(let t=0;t<r;t+=1)o=BigInt(e[t])<<BigInt(8*t)|o;return o};var Z=(e,r)=>{if((e&240)!==64)throw new Error(`Provaded incorrect type ${e} for decoding bigint`);let o=e&7,t=!!(e&8);if(o===0)return t?-0n:0n;let n=r.readBytes(o),i=p(n),c=r.readBytes(i),m=F(c);return t?-m:m};var U=new Map([[h.FALSE,!1],[h.TRUE,!0],[h.Null,null],[h.Undefined,void 0],[h.NaN,NaN],[h.Pos_Infinity,1/0],[h.Neg_Infinity,-1/0],[h.Empty_Value,""]]),q=(e,r)=>{if((e&240)!==0)throw new Error(`Provaded incorrect type ${e} for decoding contant`);if(!U.has(e))throw new Error("Not supported contsant for decoding");return U.get(e)};var Q=(e,r)=>{if((e&240)!==192)throw new Error(`Provaded incorrect type ${e} for decoding Date`);let o=e&7,t=!!(e&8);if(o===0)return new Date(0);let n=r.readBytes(o),i=p(n);return new Date(t?-i:i)};var ee=(e,r)=>{if((e&240)!==48)throw new Error(`Provaded incorrect type ${e} for decoding float`);let o=(e&7)+1,t=0;if(e&8)t=r.readByte();else for(let s=0;s<o;s+=1)t=t|1<<s;let n=r.readBytes(o),i=new Uint8Array(8),c=0;for(let s=0;s<8;s+=1)t&128>>>s&&(i[s]=n[c],c+=1);return new Float64Array(i.buffer)[0]};var re=(e,r,o,t=new Map)=>{if((e&240)!==144)throw new Error(`Provaded incorrect type ${e} for decoding map`);let n=e&7;if(n===0)return t;let i=p(r.readBytes(n)),c=t;for(let m=0;m<i;m+=1){let s=A(r.readByte(),r,o),a=A(r.readByte(),r,o);c.set(s,a)}return c};var te=(e,r,o,t={})=>{if((e&240)!==112)throw new Error(`Provaded incorrect type ${e} for decoding object`);let n=e&7;if(n===0)return t;let i=p(r.readBytes(n)),c=!!(e&8),m=c?A(null,r,o):null,s=t;for(let a=0;a<i;a+=1){let f=A(null,r,o),l=A(null,r,o);s[f]=l}if(c){let a=o.objects.classInstanceConstructorNameKey;if(a!==null){let f=o.objects.factories[m];f?Object.setPrototypeOf(s,f.prototype):Object.defineProperty(s,a,{value:m,configurable:!0,enumerable:!1,writable:!1})}}return s};var oe=(e,r,o)=>{if(e!==240)throw new Error(`Provaded incorrect type ${e} for decoding primitive object wrapper`);let t=A(r.readByte(),r,o);switch(typeof t){case"string":return new String(t);case"boolean":return new Boolean(t);case"number":return new Number(t)}throw new Error(`Can not create Primitive Object Wrapper for value ${t}, type ${typeof t}`)};var P=()=>({context:{refs:[],refByteSlice:[],readBytes:[]},objects:{classInstanceConstructorNameKey:"__jsbtConstructorName",factories:{}}});var ne=(e,r,o)=>{if((e&240)!==176)throw new Error(`Provaded incorrect type ${e} for decoding ref`);let t=!!(e&8),n=e&7,i=n===0?0:p(r.readBytes(n)),c=o.context.refs;if(!(i in c))throw new Error(`Incorrect ref ID ${i}, max id is ${c.length}`);if(t){let m=o.context.refByteSlice[i],s=o.context.readBytes.slice(m.index,m.index+m.length),a=P();a.context=o.context;let f=new C(s);return f.completeStream(),A(null,f,a)}return c[i]};var ie=(e,r,o,t=new Set)=>{if((e&240)!==128)throw new Error(`Provaded incorrect type ${e} for decoding set`);let n=e&7;if(n===0)return t;let i=p(r.readBytes(n)),c=t;for(let m=0;m<i;m+=1){let s=A(r.readByte(),r,o);c.add(s)}return c};var se=(e,r)=>{if((e&240)!==16)throw new Error(`Provaded incorrect type ${e} for decoding string`);let o=e&7;if(o===0)return"";let t=r.readBytes(o),n=p(t),i=new TextDecoder("utf-8"),c=r.readBytes(n);return i.decode(c)};var j=e=>{let r=[],o=Array.isArray(e)?e.length:e.byteLength;for(let t=0;t<o;t+=1){let n=e[t],i=e[t+1];if(i>=216&&i<=219||i>=220&&i<=223){r.push(String.fromCharCode(i<<8|n)),t+=1;continue}r.push(String.fromCharCode(n))}return r.join("")};var ce=(e,r)=>{if((e&240)!==160)throw new Error(`Provaded incorrect type ${e} for decoding symbol`);let o=e&7;if(o===0)return Symbol.for("");let t=r.readBytes(o),n=p(t),i=r.readBytes(n);return Symbol.for(j(i))};var u=(b=>(b[b.ArrayBuffer=96]="ArrayBuffer",b[b.Int8Array=97]="Int8Array",b[b.Uint8Array=98]="Uint8Array",b[b.Uint8ClampedArray=99]="Uint8ClampedArray",b[b.Int16Array=100]="Int16Array",b[b.Uint16Array=101]="Uint16Array",b[b.Int32Array=102]="Int32Array",b[b.Uint32Array=103]="Uint32Array",b[b.Float32Array=104]="Float32Array",b[b.Float64Array=105]="Float64Array",b[b.BigInt64Array=106]="BigInt64Array",b[b.BigUint64Array=107]="BigUint64Array",b))(u||{});var O=e=>e instanceof ArrayBuffer?1:e.BYTES_PER_ELEMENT;var B={};typeof Uint8Array<"u"&&(B[u.ArrayBuffer]=Uint8Array,B[u.Uint8Array]=Uint8Array);typeof Int8Array<"u"&&(B[u.Int8Array]=Int8Array);typeof Uint8ClampedArray<"u"&&(B[u.Uint8ClampedArray]=Uint8ClampedArray);typeof Int16Array<"u"&&(B[u.Int16Array]=Int16Array);typeof Uint16Array<"u"&&(B[u.Uint16Array]=Uint16Array);typeof Int32Array<"u"&&(B[u.Int32Array]=Int32Array);typeof Uint32Array<"u"&&(B[u.Uint32Array]=Uint32Array);typeof Float32Array<"u"&&(B[u.Float32Array]=Float32Array);typeof Float64Array<"u"&&(B[u.Float64Array]=Float64Array);typeof BigInt64Array<"u"&&(B[u.BigInt64Array]=BigInt64Array);typeof BigUint64Array<"u"&&(B[u.BigUint64Array]=BigUint64Array);var K={[u.ArrayBuffer]:"getUint8",[u.Int8Array]:"getInt8",[u.Uint8Array]:"getUint8",[u.Uint8ClampedArray]:"getUint8",[u.Int16Array]:"getInt16",[u.Uint16Array]:"getUint16",[u.Int32Array]:"getInt32",[u.Uint32Array]:"getUint32",[u.Float32Array]:"getFloat32",[u.Float64Array]:"getFloat64",[u.BigInt64Array]:"getBigInt64",[u.BigUint64Array]:"getBigInt64"},ae=(e,r,o)=>{if((e&240)!==96)throw new Error(`Provaded incorrect type ${e} for decoding typed array`);let t=r.readByte(),n=t&64,i=t&7,c=(t&56)>>>3,m=B[e],s=new m(0),a=O(s),f=n?p(r.readBytes(c)):p(r.readBytes(i)),l=n?p(r.readBytes(i)):f,b=K[e];if(n){let w=new m(Math.round(f/a));for(let x=0;x<l;x+=1){let T=R(r.readByte(),r),z=r.readBytes(a),H=new DataView(z.buffer);w[T]=H[b](0,!0)}return e===u.ArrayBuffer?w.buffer:w}else{let w=new m(f),x=new DataView(r.readBytes(a*f).buffer);for(let T=0;T<f;T+=1)w[T]=x[b](T*a,!0);return e===u.ArrayBuffer?w.buffer:w}};var A=(e,r,o)=>{let{refs:t,refByteSlice:n}=o.context;e===null&&(e=r.readByte());let i=e&240,c=i!==176,m=t.length,s=!0;c&&(t.push(void 0),n.push({index:r.getReadBytesIndex()-1,length:0}));let a,f=!1;switch(i){case 176:{a=ne(e,r,o),f=!0,s=!1;break}case 0:{a=q(e,r),f=!0,s=!1;break}case 16:{a=se(e,r),f=!0,s=a.length>2;break}case 32:{a=R(e,r),f=!0,s=a>255||a<-255;break}case 48:{a=ee(e,r),f=!0,s=!0;break}case 64:{a=Z(e,r),f=!0,s=!0;break}case 80:{a=J(e,r,o,t[m]=[]),f=!0,s=!0;break}case 96:{a=ae(e,r,o),f=!0;break}case 112:{a=te(e,r,o,t[m]={}),f=!0,s=!0;break}case 128:{a=ie(e,r,o,t[m]=new Set),f=!0,s=!0;break}case 144:{a=re(e,r,o,t[m]=new Map),f=!0,s=!0;break}case 160:{a=ce(e,r),f=!0,s=!0;break}case 192:{a=Q(e,r),f=!0,s=!0;break}case 240:{switch(e){case 240:{a=oe(e,r,o),f=!0,s=!0;break}default:throw new Error(`Not supported instruction ${e}`)}break}}if(f===!1)throw new Error(`Unsupported decoding value: "${e}"`);return c&&(s?(t[m]=a,n[m].length=r.getReadBytesIndex()-n[m].index):(t.pop(),n.pop())),a};var N=async(e,r)=>{if((e&240)!==32)throw new Error(`Provaded incorrect type ${e} for decoding integer`);let o=e&7,t=!!(e&8);if(o===0)return t?-0:0;let n=await r.readStreamBytes(o),i=p(n);return t?-i:i};var me=async(e,r,o,t=[])=>{if((e&240)!==80)throw new Error(`Provaded incorrect type ${e} for decoding array`);let n=e&8,i=e&7;if(i===0)return t;let c=p(await r.readStreamBytes(i)),m=n?p(await r.readStreamBytes(i)):c,s=t;if(s.length=c,n)for(let a=0;a<m;a+=1){let f=await N(await r.readStreamByte(),r),l=await S(await r.readStreamByte(),r,o);s[f]=l}else for(let a=0;a<c;a+=1){let f=await r.readStreamByte();if(f===h.Empty_Value)continue;let l=await S(f,r,o);s[a]=l}return s};var fe=async(e,r)=>{if((e&240)!==64)throw new Error(`Provaded incorrect type ${e} for decoding bigint`);let o=e&7,t=!!(e&8);if(o===0)return t?-0n:0n;let n=await r.readStreamBytes(o),i=p(n),c=await r.readStreamBytes(i),m=F(c);return t?-m:m};var de=async(e,r)=>{if((e&240)!==0)throw new Error(`Provaded incorrect type ${e} for decoding contant`);if(!U.has(e))throw new Error("Not supported contsant for decoding");return U.get(e)};var pe=async(e,r)=>{if((e&240)!==192)throw new Error(`Provaded incorrect type ${e} for decoding Date`);let o=e&7,t=!!(e&8);if(o===0)return new Date(0);let n=await r.readStreamBytes(o),i=p(n);return new Date(t?-i:i)};var ye=async(e,r)=>{if((e&240)!==48)throw new Error(`Provaded incorrect type ${e} for decoding float`);let o=(e&7)+1,t=0;if(e&8)t=await r.readStreamByte();else for(let s=0;s<o;s+=1)t=t|1<<s;let n=await r.readStreamBytes(o),i=new Uint8Array(8),c=0;for(let s=0;s<8;s+=1)t&128>>>s&&(i[s]=n[c],c+=1);return new Float64Array(i.buffer)[0]};var ue=async(e,r,o,t=new Map)=>{if((e&240)!==144)throw new Error(`Provaded incorrect type ${e} for decoding map`);let n=e&7;if(n===0)return t;let i=p(await r.readStreamBytes(n)),c=t;for(let m=0;m<i;m+=1){let s=await S(await r.readStreamByte(),r,o),a=await S(await r.readStreamByte(),r,o);c.set(s,a)}return c};var be=async(e,r,o,t={})=>{if((e&240)!==112)throw new Error(`Provaded incorrect type ${e} for decoding object`);let n=e&7;if(n===0)return t;let i=p(await r.readStreamBytes(n)),c=!!(e&8),m=c?await S(null,r,o):null,s=t;for(let a=0;a<i;a+=1){let f=await S(null,r,o),l=await S(null,r,o);s[f]=l}if(c){let a=o.objects.classInstanceConstructorNameKey;if(a!==null){let f=o.objects.factories[m];f?Object.setPrototypeOf(s,f.prototype):Object.defineProperty(s,a,{value:m,configurable:!0,enumerable:!1,writable:!1})}}return s};var le=async(e,r,o)=>{if(e!==240)throw new Error(`Provaded incorrect type ${e} for decoding primitive object wrapper`);let t=await S(null,r,o);switch(typeof t){case"string":return new String(t);case"boolean":return new Boolean(t);case"number":return new Number(t)}throw new Error(`Can not create Primitive Object Wrapper for value ${t}, type ${typeof t}`)};var ge=async(e,r,o)=>{if((e&240)!==176)throw new Error(`Provaded incorrect type ${e} for decoding ref`);let t=!!(e&8),n=e&7,i=n===0?0:p(await r.readStreamBytes(n)),c=o.context.refs;if(!(i in c))throw new Error(`Incorrect ref ID ${i}, max id is ${c.length}`);if(t){let m=o.context.refByteSlice[i],s=o.context.readBytes.slice(m.index,m.index+m.length),a=P();a.context=o.context;let f=new C(s);return f.completeStream(),A(null,f,a)}return c[i]};var he=async(e,r,o,t=new Set)=>{if((e&240)!==128)throw new Error(`Provaded incorrect type ${e} for decoding set`);let n=e&7;if(n===0)return t;let i=p(await r.readStreamBytes(n)),c=t;for(let m=0;m<i;m+=1){let s=await S(await r.readStreamByte(),r,o);c.add(s)}return c};var _e=async(e,r)=>{if((e&240)!==16)throw new Error(`Provaded incorrect type ${e} for decoding string`);let o=e&7;if(o===0)return"";let t=await r.readStreamBytes(o),n=p(t),i=new TextDecoder("utf-8"),c=await r.readStreamBytes(n);return i.decode(c)};var we=async(e,r)=>{if((e&240)!==160)throw new Error(`Provaded incorrect type ${e} for decoding symbol`);let o=e&7;if(o===0)return Symbol.for("");let t=await r.readStreamBytes(o),n=p(t),i=await r.readStreamBytes(n);return Symbol.for(j(i))};var Ie=async(e,r,o)=>{if((e&240)!==96)throw new Error(`Provaded incorrect type ${e} for decoding typed array`);let t=await r.readStreamByte(),n=t&64,i=t&7,c=(t&56)>>>3,m=B[e],s=new m(0),a=O(s),f=n?p(await r.readStreamBytes(c)):p(await r.readStreamBytes(i)),l=n?p(await r.readStreamBytes(i)):f,b=K[e];if(n){let w=new m(Math.round(f/a));for(let x=0;x<l;x+=1){let T=await N(await r.readStreamByte(),r),z=await r.readStreamBytes(a),H=new DataView(z.buffer);w[T]=H[b](0,!0)}return e===u.ArrayBuffer?w.buffer:w}else{let w=new m(f),x=new DataView((await r.readStreamBytes(a*f)).buffer);for(let T=0;T<f;T+=1)w[T]=x[b](T*a,!0);return e===u.ArrayBuffer?w.buffer:w}};var S=async(e,r,o)=>{let{refs:t,refByteSlice:n}=o.context;e===null&&(e=await r.readStreamByte());let i=e&240,c=i!==176,m=t.length,s=!0;c&&(t.push(void 0),n.push({index:r.getReadBytesIndex()-1,length:0}));let a,f=!1;switch(i){case 176:{a=await ge(e,r,o),f=!0,s=!1;break}case 0:{a=await de(e,r),f=!0,s=!1;break}case 16:{a=await _e(e,r),f=!0,s=a.length>2;break}case 32:{a=await N(e,r),f=!0,s=a>255||a<-255;break}case 48:{a=await ye(e,r),f=!0,s=!0;break}case 64:{a=await fe(e,r),f=!0,s=!0;break}case 80:{a=await me(e,r,o,t[m]=[]),f=!0,s=!0;break}case 96:{a=await Ie(e,r,o),f=!0;break}case 112:{a=await be(e,r,o,t[m]={}),f=!0,s=!0;break}case 128:{a=await he(e,r,o,t[m]=new Set),f=!0,s=!0;break}case 144:{a=await ue(e,r,o,t[m]=new Map),f=!0,s=!0;break}case 160:{a=await we(e,r),f=!0,s=!0;break}case 192:{a=await pe(e,r),f=!0,s=Math.abs(a.getTime())>255;break}case 240:{switch(e){case 240:{a=await le(e,r,o),f=!0,s=!0;break}default:throw new Error(`Not supported instruction ${e}`)}break}}if(f===!1)throw new Error(`Unsupported decoding value: "${e}"`);return c&&(s?(t[m]=a,n[m].length=r.getReadBytesIndex()-n[m].index):(t.pop(),n.pop())),a};var M=e=>typeof e=="object"&&e&&!Array.isArray(e)&&e?.constructor?.name&&e.constructor.name!=="Object";var k=e=>typeof e=="number"&&!Number.isInteger(e)&&Number.isFinite(e);var $=e=>typeof e=="number"&&Number.isInteger(e);var v=e=>e instanceof Map;var Y=e=>typeof e=="object"&&e&&!Array.isArray(e)&&e?.constructor?.name==="Object";var L=e=>e instanceof Number||e instanceof String||e instanceof Boolean;var V=e=>e instanceof Set;var G=e=>typeof ArrayBuffer<"u"&&e instanceof ArrayBuffer||typeof Int8Array<"u"&&e instanceof Int8Array||typeof Uint8Array<"u"&&e instanceof Uint8Array||typeof Uint8ClampedArray<"u"&&e instanceof Uint8ClampedArray||typeof Int16Array<"u"&&e instanceof Int16Array||typeof Uint16Array<"u"&&e instanceof Uint16Array||typeof Int32Array<"u"&&e instanceof Int32Array||typeof Uint32Array<"u"&&e instanceof Uint32Array||typeof Float32Array<"u"&&e instanceof Float32Array||typeof Float64Array<"u"&&e instanceof Float64Array||typeof BigInt64Array<"u"&&e instanceof BigInt64Array||typeof BigUint64Array<"u"&&e instanceof BigUint64Array;var g=(e,r=0)=>{if(e<0)throw new Error("integerToBytes does not support negative integers");let o=[];if(e<=4294967295)for(;e>0;)o.push(e&255),e>>>=8;else for(;e>0;){let t=e%256;o.push(t),e=Math.floor((e-t)/256)}if(r!==0){let t=r-o.length;for(;t>0;)o.push(0),t-=1}return o};var Ae=e=>{let r=0;return e.forEach(()=>{r+=1}),r};var d=(...e)=>String.fromCharCode(...e);var Xe=d(h.Empty_Value),Se=()=>Xe;var Je=d(32),Ze=d(40),D=e=>{if(!$(e))throw new Error(`Expecting "integer" type, received "${e}" (${typeof e})`);if(Math.abs(e)>9007199254740991)throw new Error("Can not encode unsafe integer");if(e===0)return Object.is(e,0)?Je:Ze;let r=[],o=Math.abs(e),t=e>0,n=g(o);return r.push(d(32|(7&n.length|(t?0:8)))),r.push(d(...n)),r.join("")};var qe=d(80),Qe=.5,Ee=(e,r)=>{if(!Array.isArray(e))throw new Error(`Expecting "array" type, received "${e}" (${typeof e})`);if(e.length===0)return qe;if(e.length>9007199254740991)throw new Error(`Provided array has too large length, limit ${9007199254740991}, received ${e.length}`);let o=Ae(e),t=o/e.length<Qe,n=g(e.length),i=[];if(i.push(d(80|(7&n.length|(t?8:0)))),i.push(d(...n)),t){let c=g(o,n.length);i.push(d(...c)),e.forEach((m,s)=>{i.push(D(s)),i.push(I(m,r))})}else for(let c=0;c<e.length;c+=1){let m=!(String(c)in e);i.push(m?Se():I(e[c],r))}return i.join("")};var Te=(e,r=0,o=!1)=>{if(e<0&&!r)throw new Error(`byteSize param should be provided for negative bigInt ${e}`);let t=[],n=e<0?-(e+1n):e;for(let i=1;r?i<=r:n;i+=1)t.push(n&0xFFn),n=n>>8n;if(e<0)for(let i=0;i<t.length;i+=1)t[i]=255n-t[i];return o?t.reverse():t};var Be=e=>typeof e=="bigint";var er=d(64),xe=e=>{if(!Be(e))throw new Error(`Expecting "bigint" type, received "${e}" (${typeof e})`);if(e===0n)return er;let r=e<0n?-e:e,o=e>0,t=[],n=Te(r),i=g(n.length);return t.push(d(64|7&i.length|(o?0:8))),t.push(d(...i)),t.push(d(...n.map(c=>Number(c)))),t.join("")};var rr=d(h.TRUE),tr=d(h.FALSE),Ce=e=>{if(typeof e!="boolean")throw new Error(`Expecting "boolean" type, received "${e}" (${typeof e})`);return e?rr:tr};var Oe=(e,r)=>{if(!M(e))throw new Error(`Expecting "object" type, received "${e}" (${typeof e})`);let o=typeof e?.toJSBT=="function"?e.toJSBT():typeof e?.toJSON=="function"?e.toJSON():e.valueOf(),t=[],n=0,i=r.objects.classInstanceConstructorNameKey,c=i&&(o[i]||e[i])||e?.constructor?.name||"";t.push(I(c,r));for(let a in o)o.hasOwnProperty(a)&&(t.push(I(a,r)),t.push(I(o[a],r)),n+=1);for(let a of Object.getOwnPropertySymbols(o))t.push(I(a,r)),t.push(I(o[a],r)),n+=1;if(n>9007199254740991)throw new Error(`Provided object has too many props, limit ${9007199254740991}, received ${n}`);let m=[],s=g(n);return m.push(d(120|7&s.length)),m.push(d(...s)),m.join("")+t.join("")};var nr=d(192),Pe=(e,r)=>{if(!(e instanceof Date))throw new Error(`Expecting "Date" type, received "${e}" (${typeof e})`);let o=e.getTime();if(Math.abs(o)>864e13)throw new Error("Can not encode invalid date");if(o===0)return nr;let t=[],n=Math.abs(o),i=o>0,c=g(n);return t.push(d(192|(7&c.length|(i?0:8)))),t.push(d(...c)),t.join("")};var Re=new ArrayBuffer(8),ir=new Float64Array(Re),E=new Uint8Array(Re),Ne=(e,r=!1)=>(ir[0]=e,r?[E[7],E[6],E[5],E[4],E[3],E[2],E[1],E[0]]:[E[0],E[1],E[2],E[3],E[4],E[5],E[6],E[7]]);var $e=(e,r=!0)=>{if(!k(e))throw new Error(`Expecting "float" type, received "${e}" (${typeof e})`);let o=Ne(e),t=0;for(;t<8&&o[t]===0;)t++;let n=8-t;if(n<=0)throw new Error("Float(0) must be encoded as Integer(0)");let i=0,c=0;if(r)for(let f=0;f<8;f++)o[f]!==0&&(i|=1<<7-f,c++);let m=!!(r&&i&&c<n-1),s=m?c:n,a=[];if(a.push(d(48|7&s-1|(m?8:0))),m){a.push(d(i));let f=new Array(c),l=0;for(let b=0;b<8;b+=1){let w=o[b];w!==0&&(f[l]=w,l+=1)}a.push(d(...f))}else{let f=new Array(n);for(let l=0;l<n;l+=1)f[l]=o[t+l];a.push(d(...f))}return a.join("")};var sr=d(h.Pos_Infinity),cr=d(h.Neg_Infinity),De=e=>{if(e!==1/0&&e!==-1/0)throw new Error(`Expecting "Infinity", received "${e}" (${typeof e})`);return e>0?sr:cr};var ar=d(144),Ue=(e,r)=>{if(!v(e))throw new Error(`Expecting "map" type, received "${e}" (${typeof e})`);if(e.size===0)return ar;if(e.size>9007199254740991)throw new Error(`Provided map has too many items, limit ${9007199254740991}, received ${e.size}`);let o=g(e.size),t=[];return t.push(d(144|7&o.length)),t.push(d(...o)),e.forEach((n,i)=>{t.push(I(i,r)),t.push(I(n,r))}),t.join("")};var mr=d(h.NaN),Fe=()=>mr;var fr=d(h.Null),je=()=>fr;var dr=d(112),Me=(e,r)=>{if(!Y(e))throw new Error(`Expecting "object" type, received "${e}" (${typeof e})`);let o=Object.keys(e),t=Object.getOwnPropertySymbols(e),n=o.length+t.length;if(n===0)return dr;if(n>9007199254740991)throw new Error(`Provided object has too many props, limit ${9007199254740991}, received ${n}`);let i=g(n),c=[];c.push(d(112|7&i.length)),c.push(d(...i));for(let m of o)c.push(I(m,r)),c.push(I(e[m],r));for(let m of t)c.push(I(m,r)),c.push(I(e[m],r));return c.join("")};var ke=(e,r)=>{if(!L(e))throw new Error(`Expecting Promitive Object Wrapper, received "${e}" (${typeof e})`);let o=[];return o.push(d(240)),o.push(I(e.valueOf(),r)),o.join("")};var X=(e,r,o)=>{if(!$(r))throw new Error(`Expecting "integer" type, received "${r}" (${typeof r})`);if(Math.abs(r)>9007199254740991)throw new Error("Can not encode unsafe integer");let t=[],n=g(r);return t.push(d(176|(e==="copy"?8:0)|7&n.length)),t.push(d(...n)),t.join("")};var pr=d(128),ve=(e,r)=>{if(!V(e))throw new Error(`Expecting "set" type, received "${e}" (${typeof e})`);if(e.size===0)return pr;if(e.size>9007199254740991)throw new Error(`Provided set has too many items, limit ${9007199254740991}, received ${e.size}`);let o=g(e.size),t=[];return t.push(d(128|7&o.length)),t.push(d(...o)),e.forEach(n=>{t.push(I(n,r))}),t.join("")};var yr=d(16),Ye=e=>{if(typeof e!="string")throw new Error(`Expecting "string" type, received "${e}" (${typeof e})`);if(e==="")return yr;let r=[],t=new TextEncoder().encode(e);if(t.byteLength>9007199254740991)throw new Error(`Too large string. ${t.byteLength} bytes, limit ${9007199254740991}`);let n=g(t.byteLength);return r.push(d(16|7&n.length)),r.push(d(...n)),r.push(d(...t)),r.join("")};var Le=e=>{let r=0;for(let o=0;o<e.length;o+=1){let t=e[o];for(let n=0;n<2;n+=1){let i=t.charCodeAt(n);isNaN(i)||(i<256?r+=1:r+=2)}}return r};var Ve=e=>{if(typeof e!="symbol")throw new Error(`Expecting "symbol" type, received "${String(e)}" (${typeof e})`);let r=[],o=Symbol.keyFor(e);if(o===void 0)throw new Error(`Not found key for symbol ${String(e)}`);let t=Le(o);if(t>9007199254740991)throw new Error(`Too large symbol key. ${t} bytes, limit ${9007199254740991}`);let n=g(t);return r.push(d(160|7&n.length)),n.length&&r.push(d(...n)),o&&r.push(o),r.join("")};var Ge=e=>{let r=0;return(e instanceof ArrayBuffer?new Uint8Array(e):e).forEach(t=>{t!==0&&(r+=1)}),r};var We=e=>{let r=e instanceof ArrayBuffer?new Uint8Array(e):e,o=O(r),t={envValueSize:r.byteLength,encKeyValueSize:0};for(let n=0;n<r.length;n+=1)if(r[n]){let c=g(n);t.encKeyValueSize+=1+ +(n>0?c.length:0)+o}return t};var ur={ArrayBuffer:u.ArrayBuffer,Int8Array:u.Int8Array,Uint8Array:u.Uint8Array,Uint8ClampedArray:u.Uint8ClampedArray,Int16Array:u.Int16Array,Uint16Array:u.Uint16Array,Int32Array:u.Int32Array,Uint32Array:u.Uint32Array,Float32Array:u.Float32Array,Float64Array:u.Float64Array,BigInt64Array:u.BigInt64Array,BigUint64Array:u.BigUint64Array},ze=(e,r)=>{if(!G(e))throw new Error(`Expecting "typedArray" type, received "${e}" (${typeof e})`);let o=e.constructor.name,t=ur[o];if(e.byteLength===0)return d(t,0);let n=e instanceof ArrayBuffer?new Uint8Array(e):e,i=O(e),c=Ge(e);if(e.byteLength>9007199254740991)throw new Error(`Provided typed array has too large length, limit ${9007199254740991}, received ${e.byteLength}`);let m=[],s=We(e),a=s.envValueSize<=s.encKeyValueSize;m.push(d(t));let f=g(e.byteLength),l=g(n.length),b=g(c);if(m.push(d(0|(a?0:64)|(a?0:(7&f.length)<<3)|(a?7&l.length:7&b.length))),a){m.push(d(...l));let w=new Uint8Array(e instanceof ArrayBuffer?e:e.buffer);m.push(d(...w))}else{m.push(d(...f)),m.push(d(...b));for(let w=0;w<n.length;w+=1)if(n[w]){let T=new Uint8Array(n.buffer,w*i,i);m.push(D(w)),m.push(d(...T))}}return m.join("")};var br=d(h.Undefined),He=()=>br;var I=(e,r)=>{let o=r.context,t=r.refs.enabled||!1,n=null;if(t){if(n=o.refMap.get(e)||null,n)return n.encodedRefLink||(n.encodedRefLink=X("link",n.refId,r)),n.encodedRefLink;n={refId:o.refMap.size,encodedRefLink:null,encodedRefCopy:null},o.refMap.set(e,n)}let i=null,c=!1,m=typeof e;switch(m){case"undefined":{c=!1,i=He();break}case"boolean":{c=!1,i=Ce(e);break}case"number":{if($(e)){c=e>255||e<-255,i=D(e);break}if(k(e)){c=!0,i=$e(e);break}if(Number.isNaN(e)){c=!1,i=Fe();break}if(e===1/0||e===-1/0){c=!1,i=De(e);break}break}case"string":{c=e.length>2,i=Ye(e);break}case"object":{if(e===null){c=!1,i=je();break}if(Array.isArray(e)){c=!0,i=Ee(e,r);break}if(Y(e)){c=!0,i=Me(e,r);break}if(V(e)){c=!0,i=ve(e,r);break}if(v(e)){c=!0,i=Ue(e,r);break}if(G(e)){c=!0,i=ze(e,r);break}if(e instanceof Date){c=!0,i=Pe(e,r);break}if(L(e)){c=!0,i=ke(e,r);break}if(M(e)){c=!0,i=Oe(e,r);break}break}case"bigint":{c=!0,i=xe(e);break}case"symbol":{c=!0,i=Ve(e);break}}if(i===null)throw new Error(`Unsupported encoding value: "${e}", type: "${m}"`);if(n)if(c){let s=o.refCopy.get(i);if(s)return n.encodedRefCopy||(n.encodedRefCopy=X("copy",s.refId,r)),n.encodedRefCopy;o.refCopy.set(i,n)}else o.refMap.delete(e);return i};var Ke=()=>({refs:{enabled:!1},context:{refMap:new Map,refCopy:new Map},objects:{classInstanceConstructorNameKey:"__jsbtConstructorName"}});var W=class{static setClassFactories(r){this._classFactories=r}static encode(r){let o=Ke();return o.refs.enabled=!0,I(r,o)}static decode(r){let o=new C(r);o.completeStream();let t=P();return t.objects.factories=this._classFactories,t.context.readBytes=o.getReadBytes(),A(null,o,t)}static async decodeStream(r){let o=P();return o.objects.factories=this._classFactories,o.context.readBytes=r.getReadBytes(),S(null,r,o)}};W._classFactories={};export{C as ByteStream,W as JSBT};
//# sourceMappingURL=index.js.map