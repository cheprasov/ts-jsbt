{"version":3,"sources":["../src/reader/ByteStream.ts","../src/converter/bytesToInteger.ts","../src/enums/EConstantByteCode.ts","../src/decoder/decodeInteger.ts","../src/decoder/decodeArray.ts","../src/converter/bytesToBigInt.ts","../src/decoder/decodeBigInt.ts","../src/decoder/decodeConstant.ts","../src/decoder/decodeDate.ts","../src/decoder/decodeFloat.ts","../src/decoder/decodeMap.ts","../src/decoder/decodeObject.ts","../src/decoder/decodePrimitiveObjectWrapper.ts","../src/decoder/options/createDecodeOptions.ts","../src/decoder/decodeRef.ts","../src/decoder/decodeSet.ts","../src/decoder/decodeString.ts","../src/converter/bytesToUtf16.ts","../src/decoder/decodeSymbol.ts","../src/enums/ETypedArrayByteCode.ts","../src/utils/typedArrays/getTypedArrayByteCount.ts","../src/decoder/decodeTypedArray.ts","../src/decoder/decode.ts","../src/decoder/decodeIntegerStream.ts","../src/decoder/decodeArrayStream.ts","../src/decoder/decodeBigIntStream.ts","../src/decoder/decodeConstantStream.ts","../src/decoder/decodeDateStream.ts","../src/decoder/decodeFloatStream.ts","../src/decoder/decodeMapStream.ts","../src/decoder/decodeObjectStream.ts","../src/decoder/decodePrimitiveObjectWrapperStream.ts","../src/decoder/decodeRefStream.ts","../src/decoder/decodeSetStream.ts","../src/decoder/decodeStringStream.ts","../src/decoder/decodeSymbolStream.ts","../src/decoder/decodeTypedArrayStream.ts","../src/decoder/decodeStream.ts","../src/utils/vars/isClassInstance.ts","../src/utils/vars/isFloat.ts","../src/utils/vars/isInteger.ts","../src/utils/vars/isMap.ts","../src/utils/vars/isObject.ts","../src/utils/vars/isPrimitiveObjectWrapper.ts","../src/utils/vars/isSet.ts","../src/utils/vars/isTypedArray.ts","../src/converter/integerToBytes.ts","../src/utils/arrays/getFilledItemsCount.ts","../src/utils/toChar.ts","../src/encoder/encodeEmptyValue.ts","../src/encoder/encodeInteger.ts","../src/encoder/encodeArray.ts","../src/converter/bigIntToBytes.ts","../src/utils/vars/isBigInt.ts","../src/encoder/encodeBigInt.ts","../src/encoder/encodeBoolean.ts","../src/encoder/encodeClassInstance.ts","../src/encoder/encodeDate.ts","../src/converter/doubleToBytes.ts","../src/encoder/encodeFloat.ts","../src/encoder/encodeInfinity.ts","../src/encoder/encodeMap.ts","../src/encoder/encodeNaN.ts","../src/encoder/encodeNull.ts","../src/encoder/encodeObject.ts","../src/encoder/encodePrimitiveObjectWrapper.ts","../src/encoder/encodeRef.ts","../src/encoder/encodeSet.ts","../src/encoder/encodeString.ts","../src/converter/getBytesSizeForString.ts","../src/encoder/encodeSymbol.ts","../src/utils/typedArrays/getFilledItemsCount.ts","../src/utils/typedArrays/calculateByteCountVariants.ts","../src/encoder/encodeTypedArray.ts","../src/encoder/encodeUndefined.ts","../src/encoder/encode.ts","../src/encoder/options/createEncodeOptions.ts","../src/JSBT.ts"],"sourcesContent":["export default class ByteStream {\n\n    protected _msg: (string|number)[];\n    protected _msgArrIndex: number = 0;\n    protected _msgChrIndex: number = 0;\n    protected _restByte: number = 0;\n\n    protected _isStreamComplete = false;\n    protected _isEOF = false;\n\n    protected _waitingPromise: Promise<void> | null = null;\n    protected _waitingPromiseResolver: (() => void) | null = null;\n    protected _waitingRejectTimeout: NodeJS.Timeout | number | null = null;\n\n    protected _readBytes: number[] = [];\n\n    constructor(msg: string | string[] | number[] = []) {\n        this._msg = Array.isArray(msg) ? [...msg] : [msg];\n    }\n\n    getReadBytesIndex(): number {\n        return this._readBytes.length;\n    }\n\n    getReadBytes(): Readonly<number[]> {\n        return this._readBytes;\n    }\n\n    addMessage(msg: string | string[] | number[]) {\n        if (Array.isArray(msg)) {\n            this._msg.push(...msg);\n        } else {\n            this._msg.push(msg);\n        }\n        if (this._waitingPromise && this._waitingPromiseResolver) {\n            this._waitingPromiseResolver();\n        }\n    }\n\n    completeStream(msg: string | string[] | number[] = []) {\n        this.addMessage(msg);\n        this._isStreamComplete = true;\n    }\n\n    isCompleteMessage(): boolean {\n        return this._isStreamComplete;\n    }\n\n    isEOF(): boolean {\n        return this._isEOF;\n    }\n\n    waitMessages(timeout: number): Promise<void> {\n        if (this._waitingPromise) {\n            return this._waitingPromise;\n        }\n        if (this._isStreamComplete) {\n            return Promise.reject('Can not wait completed stream');\n        }\n        const promise = new Promise<void>((resolve, reject) => {\n            this._waitingPromiseResolver = resolve;\n\n            this._waitingRejectTimeout = setTimeout(() => {\n                reject(`Waiting timeout ${timeout}ms is riched`);\n            }, timeout);\n        }).finally(() => {\n            if (this._waitingRejectTimeout) {\n                clearTimeout(this._waitingRejectTimeout);\n                this._waitingRejectTimeout = null;\n            }\n            this._waitingPromise = null;\n            this._waitingPromiseResolver = null;\n        });\n\n        this._waitingPromise = promise;\n        return promise;\n    }\n\n\n    async readStreamBytes(count: number = 1, timeout: number = 30_000): Promise<Uint8Array> {\n        const bytes = new Uint8Array(count);\n        let bytesLen = 0;\n\n        while (bytesLen < count) {\n            if (this._restByte) {\n                bytes[bytesLen] = this._restByte;\n                this._readBytes.push(this._restByte);\n                this._restByte = 0;\n                bytesLen += 1;\n                continue;\n            }\n\n            if (!(this._msgArrIndex in this._msg)) {\n                if (!this._isStreamComplete) {\n                    await this.waitMessages(timeout);\n                    continue;\n                }\n                this._isEOF = true;\n                throw new Error(`Can not read ${count - bytesLen} bytes`);\n            }\n\n            let charCode = NaN;\n\n            const block = this._msg[this._msgArrIndex];\n            if (typeof block === 'number') {\n                charCode = block;\n                this._msgChrIndex = 0;\n                delete this._msg[this._msgArrIndex];\n                this._msgArrIndex += 1;\n            } else {\n                charCode = block.charCodeAt(this._msgChrIndex);\n                if (charCode > 255) {\n                    this._restByte = (charCode & 0xff00) >>> 8;\n                    charCode = charCode & 0xff;\n                }\n                this._msgChrIndex += 1;\n            }\n            if (Number.isNaN(charCode)) {\n                delete this._msg[this._msgArrIndex];\n                this._msgArrIndex += 1;\n                this._msgChrIndex = 0;\n                continue;\n            }\n\n            bytes[bytesLen] = charCode;\n            this._readBytes.push(charCode);\n            bytesLen += 1;\n        }\n\n        return bytes;\n    }\n\n    async readStreamByte(): Promise<number> {\n        return (await this.readStreamBytes(1))[0];\n    }\n\n    readBytes(count: number = 1): Uint8Array {\n        if (!this._isStreamComplete) {\n            throw new Error('Sync bytes read is allowed only for completed stream');\n        }\n        const bytes = new Uint8Array(count);\n        let bytesLen = 0;\n\n        while (bytesLen < count) {\n            if (this._restByte) {\n                bytes[bytesLen] = this._restByte;\n                this._readBytes.push(this._restByte);\n                this._restByte = 0;\n                bytesLen += 1;\n                continue;\n            }\n\n            if (!(this._msgArrIndex in this._msg)) {\n                this._isEOF = true;\n                throw new Error(`Can not read ${count - bytesLen} bytes`);\n            }\n\n            let charCode = NaN;\n\n            const block = this._msg[this._msgArrIndex];\n            if (typeof block === 'number') {\n                charCode = block;\n                this._msgChrIndex = 0;\n                delete this._msg[this._msgArrIndex];\n                this._msgArrIndex += 1;\n            } else {\n                charCode = block.charCodeAt(this._msgChrIndex);\n                if (charCode > 255) {\n                    this._restByte = (charCode & 0xff00) >>> 8;\n                    charCode = charCode & 0xff;\n                }\n                this._msgChrIndex += 1;\n            }\n            if (Number.isNaN(charCode)) {\n                delete this._msg[this._msgArrIndex];\n                this._msgArrIndex += 1;\n                this._msgChrIndex = 0;\n                continue;\n            }\n\n            bytes[bytesLen] = charCode;\n            this._readBytes.push(charCode);\n            bytesLen += 1;\n        }\n\n        return bytes;\n    }\n\n    readByte(): number {\n        return this.readBytes(1)[0];\n    }\n\n}\n","export const bytesToInteger1 = (bytes: Uint8Array | number[]): number => {\n    const len = Array.isArray(bytes) ? bytes.length : bytes.byteLength;\n    if (len === 0) {\n        return 0;\n    }\n\n    let int = 0;\n    for (let i = 0; i < len; i += 1) {\n        const byte = bytes[i];\n        int = (byte * (256**i)) + int\n    }\n\n    return int;\n}\n\nexport const bytesToInteger = (bytes: Uint8Array | number[]): number => {\n    const len = Array.isArray(bytes) ? bytes.length : bytes.byteLength;\n    if (len === 0) {\n        return 0;\n    }\n\n    let int = 0;\n    for (let i = 0; i < len; i += 1) {\n        const byte = bytes[i];\n        int = (byte * (256**i)) + int\n    }\n\n    return int;\n}\n","import { ETypeByteCode } from './ETypeByteCode';\n\nexport enum EConstantByteCode {\n    FALSE        = ETypeByteCode.Constant | 0b0000_0000,\n    TRUE         = ETypeByteCode.Constant | 0b0000_0001,\n    Null         = ETypeByteCode.Constant | 0b0000_0010,\n    Undefined    = ETypeByteCode.Constant | 0b0000_0011,\n    NaN          = ETypeByteCode.Constant | 0b0000_0100,\n    Pos_Infinity = ETypeByteCode.Constant | 0b0000_0101,\n    Neg_Infinity = ETypeByteCode.Constant | 0b0000_0110,\n    Empty_Value  = ETypeByteCode.Constant | 0b0000_0111,\n}\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeInteger = (typeByte: number, stream: ByteStream): number => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Integer) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding integer`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    const isNegative = Boolean(typeByte & 0b0000_1000);\n    if (count === 0) {\n        return isNegative ? -0 : 0;\n    }\n    const bytesCount = stream.readBytes(count)\n    const int = bytesToInteger(bytesCount);\n\n    return isNegative ? -int : int;\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decode } from './decode';\nimport { decodeInteger } from './decodeInteger';\n\nexport const decodeArray = (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions,\n    initArr: any[] = []\n): any[] => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Array) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding array`);\n    }\n\n    const isKeyValueEncoding = typeByte & 0b0000_1000;\n\n    const bytesCount = typeByte & 0b0000_0111;\n    if (bytesCount === 0) {\n        return initArr;\n    }\n\n    const arrayLen = bytesToInteger(stream.readBytes(bytesCount));\n    const itemsCoint = isKeyValueEncoding ? bytesToInteger(stream.readBytes(bytesCount)) : arrayLen;\n\n    const arr = initArr;\n    arr.length = arrayLen;\n    if (isKeyValueEncoding) {\n        for (let i = 0; i < itemsCoint; i += 1) {\n            const key = decodeInteger(stream.readByte(), stream);\n            const value = decode(stream.readByte(), stream, options);\n            arr[key] = value;\n        }\n    } else {\n        for (let i = 0; i < arrayLen; i += 1) {\n            const byte = stream.readByte();\n            if (byte === EConstantByteCode.Empty_Value) {\n                continue;\n            }\n            const value = decode(byte, stream, options);\n            arr[i] = value;\n        }\n    }\n\n    return arr;\n};\n","export const bytesToBigInt = (bytes: Uint8Array | number[]): bigint => {\n    const len = Array.isArray(bytes) ? bytes.length : bytes.byteLength;\n    if (len === 0) {\n        return 0n;\n    }\n\n    let bint = 0n;\n    for (let i = 0; i < len; i += 1) {\n        const byte = BigInt(bytes[i]);\n        bint = (byte << BigInt(8 * i)) | bint\n    }\n\n    return bint;\n};\n","import { bytesToBigInt } from '../converter/bytesToBigInt';\nimport { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeBigInt = (typeByte: number, stream: ByteStream): bigint => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.BigInt) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding bigint`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    const isNegative = Boolean(typeByte & 0b0000_1000);\n    if (count === 0) {\n        return isNegative ? -0n : 0n;\n    }\n    const bytesCount = stream.readBytes(count);\n    const encodeCount = bytesToInteger(bytesCount);\n    const encodeBytes = stream.readBytes(encodeCount);\n    const bint = bytesToBigInt(encodeBytes);\n\n    return isNegative ? -bint : bint;\n};\n","import { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport type TConstant = true | false | null | undefined | typeof NaN | typeof Infinity | '' ;\n\nexport const constantMap = new Map<EConstantByteCode, TConstant>([\n    [EConstantByteCode.FALSE, false],\n    [EConstantByteCode.TRUE, true],\n    [EConstantByteCode.Null, null],\n    [EConstantByteCode.Undefined, undefined],\n    [EConstantByteCode.NaN, NaN],\n    [EConstantByteCode.Pos_Infinity, +Infinity],\n    [EConstantByteCode.Neg_Infinity, -Infinity],\n    [EConstantByteCode.Empty_Value, ''],\n]);\n\nexport const decodeConstant = (typeByte: number, stream: ByteStream): TConstant => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Constant) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding contant`);\n    }\n    if (!constantMap.has(typeByte)) {\n        throw new Error('Not supported contsant for decoding')\n    }\n    return constantMap.get(typeByte);\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeDate = (typeByte: number, stream: ByteStream): Date => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Date) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding Date`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    const isNegative = Boolean(typeByte & 0b0000_1000);\n    if (count === 0) {\n        return new Date(0);\n    }\n    const bytesCount = stream.readBytes(count)\n    const int = bytesToInteger(bytesCount);\n\n    return new Date(isNegative ? -int : int);\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeFloat = (typeByte: number, stream: ByteStream): number => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Float) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding float`);\n    }\n    const count = (typeByte & 0b0000_0111) + 1;\n    let map = 0b0000_0000;\n\n    if (typeByte & 0b0000_1000) {\n        // custom map\n        map = stream.readByte();\n    } else {\n        for (let i = 0; i < count; i += 1) {\n            map = map | (0b000_0001 << i);\n        }\n    }\n\n    const bytesCount = stream.readBytes(count)\n    const floatBytes = new Uint8Array(8);\n\n    let byteIndex = 0;\n    for (let i = 0; i < 8; i += 1) {\n        if (map & (0b1000_0000 >>> i)) {\n            floatBytes[i] = bytesCount[byteIndex];\n            byteIndex += 1;\n        }\n    }\n\n    const float = new Float64Array(floatBytes.buffer);\n    return float[0];\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decode } from './decode';\n\nexport const decodeMap = (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions,\n    initMap: Map<any, any> = new Map()\n): Map<any, any> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Map) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding map`);\n    }\n\n    const bytesCount = typeByte & 0b0000_0111;\n    if (bytesCount === 0) {\n        return initMap;\n    }\n\n    const count = bytesToInteger(stream.readBytes(bytesCount));\n\n    const map = initMap;\n\n    for (let i = 0; i < count; i += 1) {\n        const key = decode(stream.readByte(), stream, options);\n        const value = decode(stream.readByte(), stream, options);\n        map.set(key, value);\n    }\n\n    return map;\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decode } from './decode';\n\nexport const decodeObject = (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions,\n    initObj: Record<string | symbol | number, any> = {}\n): Record<string | symbol | number, any> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Object) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding object`);\n    }\n\n    const bytesCount = typeByte & 0b0000_0111;\n    if (bytesCount === 0) {\n        return initObj;\n    }\n\n    const count = bytesToInteger(stream.readBytes(bytesCount));\n\n    const isClassInstance = Boolean(typeByte & 0b0000_1000);\n    const constructorName = isClassInstance ? decode(null, stream, options) : null;\n\n    const obj: Record<string | symbol | number, any> = initObj;\n\n    for (let i = 0; i < count; i += 1) {\n        const key = decode(null, stream, options);\n        const value = decode(null, stream, options);\n        obj[key] = value;\n    }\n\n    if (isClassInstance) {\n        const constructorNameKey = options.objects.classInstanceConstructorNameKey;\n        if (constructorNameKey !== null) {\n            const classConstructor = options.objects.factories[constructorName];\n            if (classConstructor) {\n                Object.setPrototypeOf(obj, classConstructor.prototype);\n            } else {\n                Object.defineProperty(obj, constructorNameKey, {\n                    value: constructorName,\n                    configurable: true,\n                    enumerable: false,\n                    writable: false,\n                });\n            }\n        }\n    }\n\n    return obj;\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { TPrimitiveObjectWrapper } from '../types/TPrimitiveObjectWrapper';\nimport { decode } from './decode';\n\nexport const decodePrimitiveObjectWrapper = (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions\n): TPrimitiveObjectWrapper => {\n    if (typeByte !== (ETypeByteCode.Instruction | 0b0000_0000)) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding primitive object wrapper`);\n    }\n\n    const value = decode(stream.readByte(), stream, options);\n    switch (typeof value) {\n        case 'string': return new String(value);\n        case 'boolean': return new Boolean(value);\n        case 'number': return new Number(value);\n    }\n\n    throw new Error(`Can not create Primitive Object Wrapper for value ${value}, type ${typeof value}`);\n};\n","import { IDecodeOptions } from '../../types/IDecodeOptions';\n\nexport const createDecodeOptions = (): IDecodeOptions => {\n    return {\n        context: {\n            refs: [],\n            refByteSlice: [],\n            readBytes: [],\n        },\n        objects: {\n            classInstanceConstructorNameKey: '__jsbtConstructorName',\n            factories: {}\n        }\n    }\n}","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decode } from './decode';\nimport { createDecodeOptions } from './options/createDecodeOptions';\n\nexport const decodeRef = (typeByte: number, stream: ByteStream, options: IDecodeOptions): any => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Refs) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding ref`);\n    }\n\n    const isCopy = Boolean(typeByte & 0b0000_1000);\n    const count = typeByte & 0b0000_0111;\n    const id = count === 0 ? 0 : bytesToInteger(stream.readBytes(count));\n\n    const refs = options.context.refs;\n    if (!(id in refs)) {\n        throw new Error(`Incorrect ref ID ${id}, max id is ${refs.length}`);\n    }\n\n    if (isCopy) {\n        const refSlice = options.context.refByteSlice[id];\n        const slice = options.context.readBytes.slice(refSlice.index, refSlice.index + refSlice.length);\n        const decOptions = createDecodeOptions();\n        decOptions.context = options.context;\n        const st = new ByteStream(slice);\n        st.completeStream();\n        const copy = decode(null, st, decOptions);\n        return copy;\n    }\n\n    return refs[id];\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decode } from './decode';\n\nexport const decodeSet = (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions,\n    initSet: Set<any> = new Set(),\n): Set<any> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Set) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding set`);\n    }\n\n    const bytesCount = typeByte & 0b0000_0111;\n    if (bytesCount === 0) {\n        return initSet;\n    }\n\n    const count = bytesToInteger(stream.readBytes(bytesCount));\n\n    const set = initSet;\n\n    for (let i = 0; i < count; i += 1) {\n        const value = decode(stream.readByte(), stream, options);\n        set.add(value);\n    }\n\n    return set;\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeString = (typeByte: number, stream: ByteStream): string => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.String) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding string`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    if (count === 0) {\n        return '';\n    }\n\n    const bytesCount = stream.readBytes(count)\n    const bytesLength = bytesToInteger(bytesCount);\n\n    const decoder = new TextDecoder('utf-8');\n    const bytes = stream.readBytes(bytesLength);\n    return decoder.decode(bytes);\n};\n","\nexport const bytesToUtf16 = (bytes: Uint8Array | number[]): string => {\n    const msg: string[] = [];\n    const len = Array.isArray(bytes) ? bytes.length : bytes.byteLength;\n\n    for (let i = 0; i < len; i += 1) {\n        // trailing bytes\n        const currentByte = bytes[i];\n        const nextByte = bytes[i + 1];\n        // leading bytes\n        if (\n            nextByte >= 0xD8 && nextByte <= 0xDB // leading bytes\n            || nextByte >= 0xDC && nextByte <= 0xDF // trailing bytes\n        ) {\n            msg.push(String.fromCharCode((nextByte << 8) | currentByte));\n            i += 1;\n            continue;\n        }\n        msg.push(String.fromCharCode(currentByte));\n    }\n    return msg.join('');\n}","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { bytesToUtf16 } from '../converter/bytesToUtf16';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeSymbol = (typeByte: number, stream: ByteStream): symbol => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Symbol) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding symbol`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    if (count === 0) {\n        return Symbol.for('');\n    }\n\n    const bytesCount = stream.readBytes(count);\n    const strLen = bytesToInteger(bytesCount);\n\n    const bytes = stream.readBytes(strLen);\n    return Symbol.for(bytesToUtf16(bytes));\n};\n","import { ETypeByteCode } from './ETypeByteCode';\n\nexport enum ETypedArrayByteCode {\n    ArrayBuffer       = 0b0000_0000 | ETypeByteCode.Typed_Array,\n    Int8Array         = 0b0000_0001 | ETypeByteCode.Typed_Array,\n    Uint8Array        = 0b0000_0010 | ETypeByteCode.Typed_Array,\n    Uint8ClampedArray = 0b0000_0011 | ETypeByteCode.Typed_Array,\n    Int16Array        = 0b0000_0100 | ETypeByteCode.Typed_Array,\n    Uint16Array       = 0b0000_0101 | ETypeByteCode.Typed_Array,\n    Int32Array        = 0b0000_0110 | ETypeByteCode.Typed_Array,\n    Uint32Array       = 0b0000_0111 | ETypeByteCode.Typed_Array,\n    Float32Array      = 0b0000_1000 | ETypeByteCode.Typed_Array,\n    Float64Array      = 0b0000_1001 | ETypeByteCode.Typed_Array,\n    BigInt64Array     = 0b0000_1010 | ETypeByteCode.Typed_Array,\n    BigUint64Array    = 0b0000_1011 | ETypeByteCode.Typed_Array,\n}\n","import { TTypedArray } from '../../types/TTypedArray';\n\nexport const getBytesPerElement = (arr: TTypedArray | ArrayBuffer): 1 | 2 | 4 | 8 => {\n    if (arr instanceof ArrayBuffer) {\n        return 1;\n    }\n    return arr.BYTES_PER_ELEMENT as 1 | 2 | 4 | 8 ;\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { ETypedArrayByteCode } from '../enums/ETypedArrayByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { TDataViewGetter } from '../types/TDataViewGetter';\nimport { TTypedArray } from '../types/TTypedArray';\nimport { getBytesPerElement } from '../utils/typedArrays/getTypedArrayByteCount';\nimport { decodeInteger } from './decodeInteger';\n\nexport type TTypedArrayConstructor = {\n    new (init: number): TTypedArray;\n};\n\nexport const typedArrayConstructorByType: Record<number, TTypedArrayConstructor> = {};\nif (typeof(Uint8Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.ArrayBuffer] = Uint8Array;\n    typedArrayConstructorByType[ETypedArrayByteCode.Uint8Array] = Uint8Array;\n}\nif (typeof(Int8Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.Int8Array] = Int8Array;\n}\nif (typeof(Uint8ClampedArray) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.Uint8ClampedArray] = Uint8ClampedArray;\n}\nif (typeof(Int16Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.Int16Array] = Int16Array;\n}\nif (typeof(Uint16Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.Uint16Array] = Uint16Array;\n}\nif (typeof(Int32Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.Int32Array] = Int32Array;\n}\nif (typeof(Uint32Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.Uint32Array] = Uint32Array;\n}\nif (typeof(Float32Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.Float32Array] = Float32Array;\n}\nif (typeof(Float64Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.Float64Array] = Float64Array;\n}\nif (typeof(BigInt64Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.BigInt64Array] = BigInt64Array;\n}\nif (typeof(BigUint64Array) !== 'undefined') {\n    typedArrayConstructorByType[ETypedArrayByteCode.BigUint64Array] = BigUint64Array;\n}\n\nexport const dataViewGetter: Record<number, TDataViewGetter> = {\n    [ETypedArrayByteCode.ArrayBuffer]: 'getUint8',\n    [ETypedArrayByteCode.Int8Array]: 'getInt8',\n    [ETypedArrayByteCode.Uint8Array]: 'getUint8',\n    [ETypedArrayByteCode.Uint8ClampedArray]: 'getUint8',\n    [ETypedArrayByteCode.Int16Array]: 'getInt16',\n    [ETypedArrayByteCode.Uint16Array]: 'getUint16',\n    [ETypedArrayByteCode.Int32Array]: 'getInt32',\n    [ETypedArrayByteCode.Uint32Array]: 'getUint32',\n    [ETypedArrayByteCode.Float32Array]: 'getFloat32',\n    [ETypedArrayByteCode.Float64Array]: 'getFloat64',\n    [ETypedArrayByteCode.BigInt64Array]: 'getBigInt64',\n    [ETypedArrayByteCode.BigUint64Array]: 'getBigInt64',\n};\n\nexport const decodeTypedArray = (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions\n): TTypedArray | ArrayBuffer => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Typed_Array) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding typed array`);\n    }\n    const secondByte = stream.readByte();\n    const isKeyValueEncoding = secondByte & 0b0100_0000;\n\n    const itemsBytesCount = secondByte & 0b0000_0111;\n    const lengthBytesCount = (secondByte & 0b0011_1000) >>> 3;\n\n    const TypedArrayConstructor = typedArrayConstructorByType[typeByte];\n    const tarr0: TTypedArray = new TypedArrayConstructor(0);\n    const bytesPerElement = getBytesPerElement(tarr0);\n\n    const len = isKeyValueEncoding\n        ? bytesToInteger(stream.readBytes(lengthBytesCount))\n        : bytesToInteger(stream.readBytes(itemsBytesCount));\n\n    const count = isKeyValueEncoding ? bytesToInteger(stream.readBytes(itemsBytesCount)) : len;\n\n    const dataGetterName = dataViewGetter[typeByte];\n\n    if (isKeyValueEncoding) {\n        const tarr = new TypedArrayConstructor(Math.round(len / bytesPerElement));\n        for (let i = 0; i < count; i += 1) {\n            const key = decodeInteger(stream.readByte(), stream);\n            const valueBytes = stream.readBytes(bytesPerElement);\n            const view = new DataView(valueBytes.buffer);\n            tarr[key] = view[dataGetterName](0, true);\n        }\n        if (typeByte === ETypedArrayByteCode.ArrayBuffer) {\n            return tarr.buffer as ArrayBuffer;\n        }\n        return tarr;\n    } else {\n        const tarr = new TypedArrayConstructor(len);\n        const view = new DataView(stream.readBytes(bytesPerElement * len).buffer);\n        for (let i = 0; i < len; i += 1) {\n            tarr[i] = view[dataGetterName](i * bytesPerElement, true);\n        }\n        if (typeByte === ETypedArrayByteCode.ArrayBuffer) {\n            return tarr.buffer as ArrayBuffer;\n        }\n        return tarr;\n    }\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decodeArray } from './decodeArray';\nimport { decodeBigInt } from './decodeBigInt';\nimport { decodeConstant } from './decodeConstant';\nimport { decodeDate } from './decodeDate';\nimport { decodeFloat } from './decodeFloat';\nimport { decodeInteger } from './decodeInteger';\nimport { decodeMap } from './decodeMap';\nimport { decodeObject } from './decodeObject';\nimport { decodePrimitiveObjectWrapper } from './decodePrimitiveObjectWrapper';\nimport { decodeRef } from './decodeRef';\nimport { decodeSet } from './decodeSet';\nimport { decodeString } from './decodeString';\nimport { decodeSymbol } from './decodeSymbol';\nimport { decodeTypedArray } from './decodeTypedArray';\n\nexport const decode = (typeByte: number | null, stream: ByteStream, options: IDecodeOptions): any => {\n    const { refs, refByteSlice } = options.context;\n\n    if (typeByte === null) {\n        typeByte = stream.readByte();\n    }\n    const type = typeByte & 0b1111_0000;\n\n    const isRefEnabled = !(type === ETypeByteCode.Refs);\n    const refId = refs.length;\n    let isRefAllowed = true;\n    if (isRefEnabled) {\n        refs.push(undefined); // keep place\n        refByteSlice.push({\n            index: stream.getReadBytesIndex() - 1,\n            length: 0,\n        });\n    }\n\n    let result: any;\n    let isResultReceived: boolean = false;\n\n    switch (type) {\n        case ETypeByteCode.Refs: {\n            result = decodeRef(typeByte, stream, options);\n            isResultReceived = true;\n            isRefAllowed = false;\n            break;\n        }\n        case ETypeByteCode.Constant: {\n            result = decodeConstant(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = false;\n            break;\n        }\n        case ETypeByteCode.String: {\n            result = decodeString(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = result.length > 2;\n            break;\n        }\n        case ETypeByteCode.Integer: {\n            result = decodeInteger(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = result > 255 || result < -255;\n            break;\n        }\n        case ETypeByteCode.Float: {\n            result = decodeFloat(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.BigInt: {\n            result = decodeBigInt(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Array: {\n            result = decodeArray(typeByte, stream, options, (refs[refId] = []));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Typed_Array: {\n            result = decodeTypedArray(typeByte, stream, options);\n            isResultReceived = true;\n            break;\n        }\n        case ETypeByteCode.Object: {\n            result = decodeObject(typeByte, stream, options, (refs[refId] = {}));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Set: {\n            result = decodeSet(typeByte, stream, options, (refs[refId] = new Set()));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Map: {\n            result = decodeMap(typeByte, stream, options, (refs[refId] = new Map()));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Symbol: {\n            result = decodeSymbol(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Date: {\n            result = decodeDate(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Instruction: {\n            switch (typeByte) {\n                case (ETypeByteCode.Instruction | 0b1111_0000): {\n                    // Primitive Object Wrapper\n                    result = decodePrimitiveObjectWrapper(typeByte, stream, options);\n                    isResultReceived = true;\n                    isRefAllowed = true;\n                    break;\n                }\n                default: {\n                    throw new Error(`Not supported instruction ${typeByte}`);\n                }\n            }\n            break;\n        }\n    }\n\n    if (isResultReceived === false) {\n        throw new Error(`Unsupported decoding value: \"${typeByte}\"`);\n    }\n\n    if (isRefEnabled) {\n        if (isRefAllowed) {\n            refs[refId] = result;\n            refByteSlice[refId].length = stream.getReadBytesIndex() - refByteSlice[refId].index;\n        } else {\n            refs.pop();\n            refByteSlice.pop();\n        }\n    }\n    return result;\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeIntegerStream = async (typeByte: number, stream: ByteStream): Promise<number> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Integer) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding integer`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    const isNegative = Boolean(typeByte & 0b0000_1000);\n    if (count === 0) {\n        return isNegative ? -0 : 0;\n    }\n    const bytesCount = await stream.readStreamBytes(count)\n    const int = bytesToInteger(bytesCount);\n\n    return isNegative ? -int : int;\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decodeIntegerStream } from './decodeIntegerStream';\nimport { decodeStream } from './decodeStream';\n\nexport const decodeArrayStream = async (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions,\n    initArr: any[] = []\n): Promise<any[]> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Array) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding array`);\n    }\n\n    const isKeyValueEncoding = typeByte & 0b0000_1000;\n\n    const bytesCount = typeByte & 0b0000_0111;\n    if (bytesCount === 0) {\n        return initArr;\n    }\n\n    const arrayLen = bytesToInteger(await stream.readStreamBytes(bytesCount));\n    const itemsCoint = isKeyValueEncoding ? bytesToInteger(await stream.readStreamBytes(bytesCount)) : arrayLen;\n\n    const arr = initArr;\n    arr.length = arrayLen;\n    if (isKeyValueEncoding) {\n        for (let i = 0; i < itemsCoint; i += 1) {\n            const key = await decodeIntegerStream(await stream.readStreamByte(), stream);\n            const value = await decodeStream(await stream.readStreamByte(), stream, options);\n            arr[key] = value;\n        }\n    } else {\n        for (let i = 0; i < arrayLen; i += 1) {\n            const byte = await stream.readStreamByte();\n            if (byte === EConstantByteCode.Empty_Value) {\n                continue;\n            }\n            const value = await decodeStream(byte, stream, options);\n            arr[i] = value;\n        }\n    }\n\n    return arr;\n};\n","import { bytesToBigInt } from '../converter/bytesToBigInt';\nimport { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeBigIntStream = async (typeByte: number, stream: ByteStream): Promise<bigint> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.BigInt) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding bigint`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    const isNegative = Boolean(typeByte & 0b0000_1000);\n    if (count === 0) {\n        return isNegative ? -0n : 0n;\n    }\n    const bytesCount = await stream.readStreamBytes(count);\n    const encodeCount = bytesToInteger(bytesCount);\n    const encodeBytes = await stream.readStreamBytes(encodeCount);\n    const bint = bytesToBigInt(encodeBytes);\n\n    return isNegative ? -bint : bint;\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { TConstant, constantMap } from './decodeConstant';\n\nexport const decodeConstantStream = async (typeByte: number, stream: ByteStream): Promise<TConstant> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Constant) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding contant`);\n    }\n    if (!constantMap.has(typeByte)) {\n        throw new Error('Not supported contsant for decoding');\n    }\n    return constantMap.get(typeByte);\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeDateStream = async (typeByte: number, stream: ByteStream): Promise<Date> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Date) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding Date`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    const isNegative = Boolean(typeByte & 0b0000_1000);\n    if (count === 0) {\n        return new Date(0);\n    }\n    const bytesCount = await stream.readStreamBytes(count)\n    const int = bytesToInteger(bytesCount);\n\n    return new Date(isNegative ? -int : int);\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeFloatStream = async (typeByte: number, stream: ByteStream): Promise<number> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Float) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding float`);\n    }\n    const count = (typeByte & 0b0000_0111) + 1;\n    let map = 0b0000_0000;\n\n    if (typeByte & 0b0000_1000) {\n        // custom map\n        map = await stream.readStreamByte();\n    } else {\n        for (let i = 0; i < count; i += 1) {\n            map = map | (0b000_0001 << i);\n        }\n    }\n\n    const bytesCount = await stream.readStreamBytes(count);\n    const floatBytes = new Uint8Array(8);\n\n    let byteIndex = 0;\n    for (let i = 0; i < 8; i += 1) {\n        if (map & (0b1000_0000 >>> i)) {\n            floatBytes[i] = bytesCount[byteIndex];\n            byteIndex += 1;\n        }\n    }\n\n    const float = new Float64Array(floatBytes.buffer);\n    return float[0];\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decodeStream } from './decodeStream';\n\nexport const decodeMapStream = async (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions,\n    initMap: Map<any, any> = new Map()\n): Promise<Map<any, any>> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Map) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding map`);\n    }\n\n    const bytesCount = typeByte & 0b0000_0111;\n    if (bytesCount === 0) {\n        return initMap;\n    }\n\n    const count = bytesToInteger(await stream.readStreamBytes(bytesCount));\n\n    const map = initMap;\n\n    for (let i = 0; i < count; i += 1) {\n        const key = await decodeStream(await stream.readStreamByte(), stream, options);\n        const value = await decodeStream(await stream.readStreamByte(), stream, options);\n        map.set(key, value);\n    }\n\n    return map;\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decodeStream } from './decodeStream';\n\nexport const decodeObjectStream = async (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions,\n    initObj: Record<string | symbol | number, any> = {}\n): Promise<Record<string | symbol | number, any>> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Object) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding object`);\n    }\n\n    const bytesCount = typeByte & 0b0000_0111;\n    if (bytesCount === 0) {\n        return initObj;\n    }\n\n    const count = bytesToInteger(await stream.readStreamBytes(bytesCount));\n\n    const isClassInstance = Boolean(typeByte & 0b0000_1000);\n    const constructorName = isClassInstance ? await decodeStream(null, stream, options) : null;\n\n    const obj: Record<string | symbol | number, any> = initObj;\n\n    for (let i = 0; i < count; i += 1) {\n        const key = await decodeStream(null, stream, options);\n        const value = await decodeStream(null, stream, options);\n        obj[key] = value;\n    }\n\n    if (isClassInstance) {\n        const constructorNameKey = options.objects.classInstanceConstructorNameKey;\n        if (constructorNameKey !== null) {\n            const classConstructor = options.objects.factories[constructorName];\n            if (classConstructor) {\n                Object.setPrototypeOf(obj, classConstructor.prototype);\n            } else {\n                Object.defineProperty(obj, constructorNameKey, {\n                    value: constructorName,\n                    configurable: true,\n                    enumerable: false,\n                    writable: false,\n                });\n            }\n        }\n    }\n\n    return obj;\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { TPrimitiveObjectWrapper } from '../types/TPrimitiveObjectWrapper';\nimport { decodeStream } from './decodeStream';\n\nexport const decodePrimitiveObjectWrapperStream = async (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions\n): Promise<TPrimitiveObjectWrapper> => {\n    if (typeByte !== (ETypeByteCode.Instruction | 0b0000_0000)) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding primitive object wrapper`);\n    }\n\n    const value = await decodeStream(null, stream, options);\n    switch (typeof value) {\n        case 'string': return new String(value);\n        case 'boolean': return new Boolean(value);\n        case 'number': return new Number(value);\n    }\n\n    throw new Error(`Can not create Primitive Object Wrapper for value ${value}, type ${typeof value}`);\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decode } from './decode';\nimport { createDecodeOptions } from './options/createDecodeOptions';\n\nexport const decodeRefStream = async (typeByte: number, stream: ByteStream, options: IDecodeOptions): Promise<any> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Refs) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding ref`);\n    }\n\n    const isCopy = Boolean(typeByte & 0b0000_1000);\n    const count = typeByte & 0b0000_0111;\n    const id = count === 0 ? 0 : bytesToInteger(await stream.readStreamBytes(count));\n\n    const refs = options.context.refs;\n    if (!(id in refs)) {\n        throw new Error(`Incorrect ref ID ${id}, max id is ${refs.length}`);\n    }\n\n    if (isCopy) {\n        const refSlice = options.context.refByteSlice[id];\n        const slice = options.context.readBytes.slice(refSlice.index, refSlice.index + refSlice.length);\n        const decOptions = createDecodeOptions();\n        decOptions.context = options.context;\n        const st = new ByteStream(slice);\n        st.completeStream();\n        const copy = decode(null, st, decOptions);\n        return copy;\n    }\n\n    return refs[id];\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decodeStream } from './decodeStream';\n\nexport const decodeSetStream = async (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions,\n    initSet: Set<any> = new Set(),\n): Promise<Set<any>> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Set) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding set`);\n    }\n\n    const bytesCount = typeByte & 0b0000_0111;\n    if (bytesCount === 0) {\n        return initSet;\n    }\n\n    const count = bytesToInteger(await stream.readStreamBytes(bytesCount));\n\n    const set = initSet;\n\n    for (let i = 0; i < count; i += 1) {\n        const value = await decodeStream(await stream.readStreamByte(), stream, options);\n        set.add(value);\n    }\n\n    return set;\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeStringStream = async (typeByte: number, stream: ByteStream): Promise<string> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.String) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding string`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    if (count === 0) {\n        return '';\n    }\n\n    const bytesCount = await stream.readStreamBytes(count)\n    const bytesLength = bytesToInteger(bytesCount);\n\n    const decoder = new TextDecoder('utf-8');\n    const bytes = await stream.readStreamBytes(bytesLength);\n    return decoder.decode(bytes);\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { bytesToUtf16 } from '../converter/bytesToUtf16';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\n\nexport const decodeSymbolStream = async (typeByte: number, stream: ByteStream): Promise<symbol> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Symbol) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding symbol`);\n    }\n\n    const count = typeByte & 0b0000_0111;\n    if (count === 0) {\n        return Symbol.for('');\n    }\n\n    const bytesCount = await stream.readStreamBytes(count);\n    const strLen = bytesToInteger(bytesCount);\n\n    const bytes = await stream.readStreamBytes(strLen);\n    return Symbol.for(bytesToUtf16(bytes));\n};\n","import { bytesToInteger } from '../converter/bytesToInteger';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { ETypedArrayByteCode } from '../enums/ETypedArrayByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { TTypedArray } from '../types/TTypedArray';\nimport { getBytesPerElement } from '../utils/typedArrays/getTypedArrayByteCount';\nimport { decodeIntegerStream } from './decodeIntegerStream';\nimport { dataViewGetter, typedArrayConstructorByType } from './decodeTypedArray';\n\nexport const decodeTypedArrayStream = async (\n    typeByte: number,\n    stream: ByteStream,\n    options: IDecodeOptions\n): Promise<TTypedArray | ArrayBuffer> => {\n    if ((typeByte & 0b1111_0000) !== ETypeByteCode.Typed_Array) {\n        throw new Error(`Provaded incorrect type ${typeByte} for decoding typed array`);\n    }\n    const secondByte = await stream.readStreamByte();\n    const isKeyValueEncoding = secondByte & 0b0100_0000;\n\n    const itemsBytesCount = secondByte & 0b0000_0111;\n    const lengthBytesCount = (secondByte & 0b0011_1000) >>> 3;\n\n    const TypedArrayConstructor = typedArrayConstructorByType[typeByte];\n    const tarr0: TTypedArray = new TypedArrayConstructor(0);\n    const bytesPerElement = getBytesPerElement(tarr0);\n\n    const len = isKeyValueEncoding\n        ? bytesToInteger(await stream.readStreamBytes(lengthBytesCount))\n        : bytesToInteger(await stream.readStreamBytes(itemsBytesCount));\n\n    const count = isKeyValueEncoding ? bytesToInteger(await stream.readStreamBytes(itemsBytesCount)) : len;\n\n    const dataGetterName = dataViewGetter[typeByte];\n\n    if (isKeyValueEncoding) {\n        const tarr = new TypedArrayConstructor(Math.round(len / bytesPerElement));\n        for (let i = 0; i < count; i += 1) {\n            const key = await decodeIntegerStream(await stream.readStreamByte(), stream);\n            const valueBytes = await stream.readStreamBytes(bytesPerElement);\n            const view = new DataView(valueBytes.buffer);\n            tarr[key] = view[dataGetterName](0, true);\n        }\n        if (typeByte === ETypedArrayByteCode.ArrayBuffer) {\n            return tarr.buffer as ArrayBuffer;\n        }\n        return tarr;\n    } else {\n        const tarr = new TypedArrayConstructor(len);\n        const view = new DataView((await stream.readStreamBytes(bytesPerElement * len)).buffer);\n        for (let i = 0; i < len; i += 1) {\n            tarr[i] = view[dataGetterName](i * bytesPerElement, true);\n        }\n        if (typeByte === ETypedArrayByteCode.ArrayBuffer) {\n            return tarr.buffer as ArrayBuffer;\n        }\n        return tarr;\n    }\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport ByteStream from '../reader/ByteStream';\nimport { IDecodeOptions } from '../types/IDecodeOptions';\nimport { decodeArrayStream } from './decodeArrayStream';\nimport { decodeBigIntStream } from './decodeBigIntStream';\nimport { decodeConstantStream } from './decodeConstantStream';\nimport { decodeDateStream } from './decodeDateStream';\nimport { decodeFloatStream } from './decodeFloatStream';\nimport { decodeIntegerStream } from './decodeIntegerStream';\nimport { decodeMapStream } from './decodeMapStream';\nimport { decodeObjectStream } from './decodeObjectStream';\nimport { decodePrimitiveObjectWrapperStream } from './decodePrimitiveObjectWrapperStream';\nimport { decodeRefStream } from './decodeRefStream';\nimport { decodeSetStream } from './decodeSetStream';\nimport { decodeStringStream } from './decodeStringStream';\nimport { decodeSymbolStream } from './decodeSymbolStream';\nimport { decodeTypedArrayStream } from './decodeTypedArrayStream';\n\nexport const decodeStream = async (\n    typeByte: number | null,\n    stream: ByteStream,\n    options: IDecodeOptions\n): Promise<any> => {\n    const { refs, refByteSlice } = options.context;\n\n    if (typeByte === null) {\n        typeByte = await stream.readStreamByte();\n    }\n    const type = typeByte & 0b1111_0000;\n\n    const isRefEnabled = !(type === ETypeByteCode.Refs);\n    const refId = refs.length;\n    let isRefAllowed = true;\n    if (isRefEnabled) {\n        refs.push(undefined); // keep place\n        refByteSlice.push({\n            index: stream.getReadBytesIndex() - 1,\n            length: 0,\n        });\n    }\n\n    let result: any;\n    let isResultReceived: boolean = false;\n\n    switch (type) {\n        case ETypeByteCode.Refs: {\n            result = await decodeRefStream(typeByte, stream, options);\n            isResultReceived = true;\n            isRefAllowed = false;\n            break;\n        }\n        case ETypeByteCode.Constant: {\n            result = await decodeConstantStream(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = false;\n            break;\n        }\n        case ETypeByteCode.String: {\n            result = await decodeStringStream(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = result.length > 2;\n            break;\n        }\n        case ETypeByteCode.Integer: {\n            result = await decodeIntegerStream(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = result > 255 || result < -255;\n            break;\n        }\n        case ETypeByteCode.Float: {\n            result = await decodeFloatStream(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.BigInt: {\n            result = await decodeBigIntStream(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Array: {\n            result = await decodeArrayStream(typeByte, stream, options, (refs[refId] = []));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Typed_Array: {\n            result = await decodeTypedArrayStream(typeByte, stream, options);\n            isResultReceived = true;\n            break;\n        }\n        case ETypeByteCode.Object: {\n            result = await decodeObjectStream(typeByte, stream, options, (refs[refId] = {}));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Set: {\n            result = await decodeSetStream(typeByte, stream, options, (refs[refId] = new Set()));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Map: {\n            result = await decodeMapStream(typeByte, stream, options, (refs[refId] = new Map()));\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Symbol: {\n            result = await decodeSymbolStream(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = true;\n            break;\n        }\n        case ETypeByteCode.Date: {\n            result = await decodeDateStream(typeByte, stream);\n            isResultReceived = true;\n            isRefAllowed = Math.abs(result.getTime()) > 255;\n            break;\n        }\n        case ETypeByteCode.Instruction: {\n            switch (typeByte) {\n                case (ETypeByteCode.Instruction | 0b1111_0000): {\n                    // Primitive Object Wrapper\n                    result = await decodePrimitiveObjectWrapperStream(typeByte, stream, options);\n                    isResultReceived = true;\n                    isRefAllowed = true;\n                    break;\n                }\n                default: {\n                    throw new Error(`Not supported instruction ${typeByte}`);\n                }\n            }\n            break;\n        }\n    }\n\n    if (isResultReceived === false) {\n        throw new Error(`Unsupported decoding value: \"${typeByte}\"`);\n    }\n\n    if (isRefEnabled) {\n        if (isRefAllowed) {\n            refs[refId] = result;\n            refByteSlice[refId].length = stream.getReadBytesIndex() - refByteSlice[refId].index;\n        } else {\n            refs.pop();\n            refByteSlice.pop();\n        }\n    }\n    return result;\n};\n","\nexport const isClassInstance = (value: any): boolean => {\n    return (\n        typeof value === 'object' &&\n        value &&\n        !Array.isArray(value) &&\n        value?.constructor?.name &&\n        value.constructor.name !== 'Object'\n    );\n};\n","export const isFloat = (value: any): value is number => {\n    return typeof value === 'number'\n        && !Number.isInteger(value)\n        && Number.isFinite(value);\n};\n","\nexport const isInteger = (value: any): value is number => {\n    return typeof value === 'number' && Number.isInteger(value);\n}","\nexport const isMap = (value: any): value is Map<any, any> => {\n    return value instanceof Map;\n}\n","import { TObject } from '../../types/TObject';\n\nexport const isObject = (value: any): value is TObject => {\n    return typeof value === 'object' && value && !Array.isArray(value) && value?.constructor?.name === 'Object';\n}\n","import { TPrimitiveObjectWrapper } from '../../types/TPrimitiveObjectWrapper';\n\nexport const isPrimitiveObjectWrapper = (value: any): value is TPrimitiveObjectWrapper => {\n    return value instanceof Number || value instanceof String || value instanceof Boolean;\n};\n","\nexport const isSet = (value: any): value is Set<any> => {\n    return value instanceof Set;\n}\n","import { TTypedArray } from '../../types/TTypedArray';\n\nexport const isTypedArray = (value: any): value is TTypedArray => {\n    return (\n        typeof(ArrayBuffer) !== 'undefined' && value instanceof ArrayBuffer ||\n        typeof(Int8Array) !== 'undefined' && value instanceof Int8Array ||\n        typeof(Uint8Array) !== 'undefined' && value instanceof Uint8Array ||\n        typeof(Uint8ClampedArray) !== 'undefined' && value instanceof Uint8ClampedArray ||\n        typeof(Int16Array) !== 'undefined' && value instanceof Int16Array ||\n        typeof(Uint16Array) !== 'undefined' && value instanceof Uint16Array ||\n        typeof(Int32Array) !== 'undefined' && value instanceof Int32Array ||\n        typeof(Uint32Array) !== 'undefined' && value instanceof Uint32Array ||\n        typeof(Float32Array) !== 'undefined' && value instanceof Float32Array ||\n        typeof(Float64Array) !== 'undefined' && value instanceof Float64Array ||\n        typeof(BigInt64Array) !== 'undefined' && value instanceof BigInt64Array ||\n        typeof(BigUint64Array) !== 'undefined' && value instanceof BigUint64Array\n    );\n};\n","// prettier-ignore\nconst UINT32_MAX = 0xFFFFFFFF;\n\nexport const integerToBytes = (num: number, byteSize: number = 0): number[] => {\n    if (num < 0) {\n        throw new Error('integerToBytes does not support negative integers');\n    }\n    const bytes: number[] = [];\n\n    // Bits operations only for int32\n    if (num <= UINT32_MAX) {\n        while (num > 0) {\n            bytes.push(num & 0xff);\n            num >>>= 8;\n        }\n    } else {\n        while (num > 0) {\n            const n = num % 256;\n            bytes.push(n);\n            num = Math.floor((num - n) / 256);\n        }\n    }\n\n    if (byteSize !== 0) {\n        let count = byteSize - bytes.length;\n        while (count > 0) {\n            bytes.push(0);\n            count -= 1;\n        }\n    }\n\n    return bytes;\n};\n","\nexport const getFilledItemsCount = (arr: any[]): number => {\n    let count = 0;\n    // Unassigned values are not iterated in a forEach loop.\n    arr.forEach(() => {\n        count += 1\n    });\n    return count;\n}\n","\nexport const toChar = (...codes: number[]): string => {\n    return String.fromCharCode(...codes);\n}\n","import { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { toChar } from '../utils/toChar';\n\nconst EMPTY_VALUE_BYTE_CHR = toChar(EConstantByteCode.Empty_Value)\n\nexport const encodeEmptyValue = (): string => {\n    return EMPTY_VALUE_BYTE_CHR;\n}","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { toChar } from '../utils/toChar';\nimport { isInteger } from '../utils/vars/isInteger';\n\nconst POS_ZERO_BYTE_CHAR = toChar(ETypeByteCode.Integer & 0b1111_0000);\nconst NEG_ZERO_BYTE_CHAR = toChar(ETypeByteCode.Integer & 0b1111_0000 | 0b0000_1000);\n\nexport const encodeInteger = (value: number): string => {\n    if (!isInteger(value)) {\n        throw new Error(`Expecting \"integer\" type, received \"${value}\" (${typeof value})`);\n    }\n    if (Math.abs(value) > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Can not encode unsafe integer`);\n    }\n    if (value === 0) {\n        return Object.is(value, 0) ? POS_ZERO_BYTE_CHAR : NEG_ZERO_BYTE_CHAR;\n    }\n    const msg: string[] = [];\n    const val = Math.abs(value);\n    const isPositive = value > 0;\n\n    const bytes = integerToBytes(val);\n    // type byte\n    msg.push(toChar(ETypeByteCode.Integer | ((0b0000_0111 & bytes.length) | (isPositive ? 0 : 0b0000_1000))));\n    // encode bytes\n    msg.push(toChar(...bytes));\n\n    return msg.join('');\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\nimport { getFilledItemsCount } from '../utils/arrays/getFilledItemsCount';\nimport { toChar } from '../utils/toChar';\nimport { encodeEmptyValue } from './encodeEmptyValue';\nimport { encodeInteger } from './encodeInteger';\nimport { encode } from './encode';\n\nconst EMPTY_ARRAY_BYTE_CHAR = toChar(ETypeByteCode.Array & 0b1111_0000);\n\nconst SPARSE_RATE = 0.5;\n\nexport const encodeArray = (arr: any[], options: IEncodeOptions): string => {\n    if (!Array.isArray(arr)) {\n        throw new Error(`Expecting \"array\" type, received \"${arr}\" (${typeof arr})`);\n    }\n\n    if (arr.length === 0) {\n        return EMPTY_ARRAY_BYTE_CHAR;\n    }\n\n    if (arr.length > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided array has too large length, limit ${MAX_7_BYTES_INTEGER}, received ${arr.length}`);\n    }\n\n    const filledCount = getFilledItemsCount(arr);\n    const isSparseEncoding = filledCount / arr.length < SPARSE_RATE;\n    const bytes = integerToBytes(arr.length);\n\n    const msg: string[] = [];\n\n    // type byte\n    msg.push(toChar(\n        ETypeByteCode.Array\n        | ((0b0000_0111 & bytes.length)\n        | (isSparseEncoding ? 0b0000_1000 : 0))\n    ));\n\n    // length\n    msg.push(toChar(...bytes));\n\n    if (isSparseEncoding) {\n        // Sparse Array Encoding\n        // Encode only filled items with keys\n\n        // Items count\n        const countBytes = integerToBytes(filledCount, bytes.length);\n        msg.push(toChar(...countBytes));\n\n        arr.forEach((item, index) => {\n            msg.push(encodeInteger(index));\n            msg.push(encode(item, options));\n        });\n    } else {\n        // Dense Array Encoding\n        // Encode all items including Empty Values\n        for (let i = 0; i < arr.length; i += 1) {\n            const isEmptyValue = !(String(i) in arr);\n            msg.push(isEmptyValue ? encodeEmptyValue() : encode(arr[i], options));\n        }\n    }\n\n    return msg.join('');\n};\n","export const bigIntToBytes = (bint: bigint, byteSize: number = 0, bigEndianOrder: boolean = false): bigint[] => {\n    if (bint < 0 && !byteSize) {\n        throw new Error(`byteSize param should be provided for negative bigInt ${bint}`);\n    }\n    const bytes: bigint[] = [];\n    let num = bint < 0 ? -(bint + 1n) : bint;\n    for (let i = 1; byteSize ? i <= byteSize : num; i += 1) {\n        bytes.push(num & 0xFFn);\n        num = num >> 8n;\n    }\n\n    if (bint < 0) {\n        for (let i = 0; i < bytes.length; i += 1) {\n            bytes[i] = 255n - bytes[i];\n        }\n        //bytes.push(255n);\n    }\n\n    return bigEndianOrder ? bytes.reverse() : bytes;\n}","\nexport const isBigInt = (value: any): value is bigint => {\n    return typeof value === 'bigint';\n}\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { bigIntToBytes } from '../converter/bigIntToBytes';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { toChar } from '../utils/toChar';\nimport { isBigInt } from '../utils/vars/isBigInt';\n\nconst ZERO_BYTE_CHAR = toChar(ETypeByteCode.BigInt & 0b1111_0000);\n\nexport const encodeBigInt = (value: bigint): string => {\n    if (!isBigInt(value)) {\n        throw new Error(`Expecting \"bigint\" type, received \"${value}\" (${typeof value})`);\n    }\n\n    if (value === 0n) {\n        return ZERO_BYTE_CHAR;\n    }\n\n    const val = value < 0n ? -value : value;\n    const isPositive = value > 0;\n\n    const msg: string[] = [];\n    const bytes = bigIntToBytes(val);\n    const lenBytes = integerToBytes(bytes.length);\n    // type byte\n    msg.push(toChar(\n        ETypeByteCode.BigInt | (0b0000_0111 & lenBytes.length) | (isPositive ? 0 : 0b0000_1000)\n    ));\n    // length bytes\n    msg.push(toChar(...lenBytes));\n    // encode bytes\n    msg.push(toChar(...bytes.map((i) => Number(i))));\n\n    return msg.join('');\n};\n","import { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { toChar } from '../utils/toChar';\n\nconst TRUE_BYTE_CHR = toChar(EConstantByteCode.TRUE);\nconst FALSE_BYTE_CHR = toChar(EConstantByteCode.FALSE);\n\nexport const encodeBoolean = (value: boolean): string => {\n    if (typeof value !== 'boolean') {\n        throw new Error(`Expecting \"boolean\" type, received \"${value}\" (${typeof value})`);\n    }\n    return value ? TRUE_BYTE_CHR : FALSE_BYTE_CHR;\n}","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\nimport { TObject } from '../types/TObject';\nimport { toChar } from '../utils/toChar';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { encode } from './encode';\nimport { isClassInstance } from '../utils/vars/isClassInstance';\n\nexport const encodeClassInstance = (obj: TObject, options: IEncodeOptions): string => {\n    if (!isClassInstance(obj)) {\n        throw new Error(`Expecting \"object\" type, received \"${obj}\" (${typeof obj})`);\n    }\n    const props =\n        typeof obj?.toJSBT === 'function'\n            ? obj.toJSBT()\n            : typeof obj?.toJSON === 'function'\n                ? obj.toJSON()\n                : obj.valueOf();\n\n    const msgBody: string[] = [];\n    let count = 0;\n\n    // constructor name\n    const constructorNameKey = options.objects.classInstanceConstructorNameKey;\n    const constructorName =\n        (constructorNameKey && (props[constructorNameKey] || obj[constructorNameKey])) || obj?.constructor?.name || '';\n    msgBody.push(encode(constructorName, options));\n\n    for (const key in props) {\n        if (!props.hasOwnProperty(key)) {\n            continue;\n        }\n        msgBody.push(encode(key, options));\n        msgBody.push(encode(props[key], options));\n        count += 1;\n    }\n\n    for (const sym of Object.getOwnPropertySymbols(props)) {\n        msgBody.push(encode(sym, options));\n        msgBody.push(encode(props[sym], options));\n        count += 1;\n    }\n\n    if (count > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided object has too many props, limit ${MAX_7_BYTES_INTEGER}, received ${count}`);\n    }\n\n    const msgHeaders: string[] = [];\n    const countBytes = integerToBytes(count);\n\n    // type byte\n    msgHeaders.push(\n        toChar(\n            ETypeByteCode.Object |\n                0b0000_1000 | // Class Instance\n                (0b0000_0111 & countBytes.length)\n        )\n    );\n\n    // length\n    msgHeaders.push(toChar(...countBytes));\n\n    return msgHeaders.join('') + msgBody.join('');\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_DATE_INTEGER } from '../constants';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { toChar } from '../utils/toChar';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\n\nconst ZERO_BYTE_CHAR = toChar(ETypeByteCode.Date & 0b1111_0000);\n\nexport const encodeDate = (value: Date, options?: IEncodeOptions): string => {\n    if (!(value instanceof Date)) {\n        throw new Error(`Expecting \"Date\" type, received \"${value}\" (${typeof value})`);\n    }\n    const ms = value.getTime();\n    if (Math.abs(ms) > MAX_DATE_INTEGER) {\n        throw new Error(`Can not encode invalid date`);\n    }\n    if (ms === 0) {\n        return ZERO_BYTE_CHAR;\n    }\n    const msg: string[] = [];\n    const val = Math.abs(ms);\n    const isPositive = ms > 0;\n\n    const bytes = integerToBytes(val);\n    // type byte\n    msg.push(toChar(ETypeByteCode.Date | ((0b0000_0111 & bytes.length) | (isPositive ? 0 : 0b0000_1000))));\n    // encode bytes\n    msg.push(toChar(...bytes));\n\n    return msg.join('');\n};\n","import { TUint8 } from '../types/TUint8';\n\n// reusable shared buffers\nconst _buffer = new ArrayBuffer(8);\nconst _float64 = new Float64Array(_buffer);\nconst _uint8 = new Uint8Array(_buffer);\n\nexport const doubleToBytes = (value: number, bigEndianOrder = false): TUint8 => {\n    _float64[0] = value;\n\n    if (!bigEndianOrder) {\n        // little-endian fast path\n        return [\n            _uint8[0],\n            _uint8[1],\n            _uint8[2],\n            _uint8[3],\n            _uint8[4],\n            _uint8[5],\n            _uint8[6],\n            _uint8[7],\n        ];\n    }\n\n    // big-endian (rare path)\n    return [\n        _uint8[7],\n        _uint8[6],\n        _uint8[5],\n        _uint8[4],\n        _uint8[3],\n        _uint8[2],\n        _uint8[1],\n        _uint8[0],\n    ];\n};","import { doubleToBytes } from '../converter/doubleToBytes';\nimport { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { toChar } from '../utils/toChar';\nimport { isFloat } from '../utils/vars/isFloat';\n\nexport const encodeFloat = (value: number, mapping: boolean = true): string => {\n    if (!isFloat(value)) {\n        throw new Error(`Expecting \"float\" type, received \"${value}\" (${typeof value})`);\n    }\n\n    // IMPORTANT: assume doubleToBytes returns an array-like of length 8 (number[])\n    const bytes = doubleToBytes(value);\n\n    // Find leading zeros WITHOUT shift()\n    let startTrim = 0;\n    while (startTrim < 8 && bytes[startTrim] === 0) startTrim++;\n\n    const trimmedLen = 8 - startTrim;\n    if (trimmedLen <= 0) {\n        throw new Error('Float(0) must be encoded as Integer(0)');\n    }\n\n    // Build byteMap + count of non-zero bytes (mapping candidate)\n    let byteMap = 0;\n    let mappedCount = 0;\n\n    if (mapping) {\n        for (let i = 0; i < 8; i++) {\n            const b = bytes[i];\n            if (b !== 0) {\n                byteMap |= (1 << (7 - i)); // faster than 2**(7-i)\n                mappedCount++;\n            }\n        }\n    }\n\n    // mapping if saves more than ~1 byte vs trimmed payload\n    const isMapping = !!(mapping && byteMap && mappedCount < (trimmedLen - 1));\n    const payloadLen = isMapping ? mappedCount : trimmedLen;\n\n    // Pre-allocate roughly: 1 type + maybe 1 map + payload (as one toChar call)\n    const msg: string[] = [];\n\n    // type byte\n    msg.push(toChar(\n        ETypeByteCode.Float\n            | (0b0000_0111 & (payloadLen - 1))\n            | (isMapping ? 0b0000_1000 : 0)\n    ));\n\n    if (isMapping) {\n        // mapping byte\n        msg.push(toChar(byteMap));\n\n        // payload: only non-zero bytes, in original order\n        // We still need a number[] for toChar(...codes), but it's at most 8 items\n        const out: number[] = new Array(mappedCount);\n        let j = 0;\n        for (let i = 0; i < 8; i += 1) {\n            const b = bytes[i];\n            if (b !== 0) {\n                out[j] = b;\n                j += 1;\n            }\n        }\n        msg.push(toChar(...out));\n    } else {\n        // payload: trimmed bytes\n        // Again, max 8 bytes: cheap\n        const out: number[] = new Array(trimmedLen);\n        for (let i = 0; i < trimmedLen; i += 1) {\n            out[i] = bytes[startTrim + i];\n        }\n        msg.push(toChar(...out));\n    }\n\n    return msg.join('');\n};\n","import { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { toChar } from '../utils/toChar';\n\nconst POS_INFINITY_CHR = toChar(EConstantByteCode.Pos_Infinity);\nconst NEG_INFINITY_CHR = toChar(EConstantByteCode.Neg_Infinity);\n\nexport const encodeInfinity = (value: number): string => {\n    if (value !== Infinity && value !== -Infinity) {\n        throw new Error(`Expecting \"Infinity\", received \"${value}\" (${typeof value})`);\n    }\n    return value > 0 ? POS_INFINITY_CHR : NEG_INFINITY_CHR;\n}","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\nimport { toChar } from '../utils/toChar';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { isMap } from '../utils/vars/isMap';\nimport { encode } from './encode';\n\nconst EMPTY_MAP_BYTE_CHAR = toChar(ETypeByteCode.Map & 0b1111_0000);\n\nexport const encodeMap = (map: Map<any, any>, options: IEncodeOptions): string => {\n    if (!isMap(map)) {\n        throw new Error(`Expecting \"map\" type, received \"${map}\" (${typeof map})`);\n    }\n\n    if (map.size === 0) {\n        return EMPTY_MAP_BYTE_CHAR;\n    }\n\n    if (map.size > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided map has too many items, limit ${MAX_7_BYTES_INTEGER}, received ${map.size}`);\n    }\n\n    const sizeBytes = integerToBytes(map.size);\n\n    const msg: string[] = [];\n    // type byte\n    msg.push(toChar(\n        ETypeByteCode.Map\n        | (0b0000_0111 & sizeBytes.length)\n    ));\n\n    // count\n    msg.push(toChar(...sizeBytes));\n\n    map.forEach((value, key) => {\n        msg.push(encode(key, options));\n        msg.push(encode(value, options));\n    });\n\n    return msg.join('');\n};\n","import { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { toChar } from '../utils/toChar';\n\nconst NAN_BYTE = toChar(EConstantByteCode.NaN)\n\nexport const encodeNaN = (): string => {\n    return NAN_BYTE;\n}","import { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { toChar } from '../utils/toChar';\n\nconst NULL_BYTE = toChar(EConstantByteCode.Null)\n\nexport const encodeNull = (): string => {\n    return NULL_BYTE;\n}","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\nimport { TObject } from '../types/TObject';\nimport { isObject } from '../utils/vars/isObject';\nimport { toChar } from '../utils/toChar';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { encode } from './encode';\n\nconst EMPTY_OBJECT_BYTE_CHAR = toChar(ETypeByteCode.Object & 0b1111_0000);\n\nexport const encodeObject = (obj: TObject, options: IEncodeOptions): string => {\n    if (!isObject(obj)) {\n        throw new Error(`Expecting \"object\" type, received \"${obj}\" (${typeof obj})`);\n    }\n\n    const keys = Object.keys(obj);\n    const syms = Object.getOwnPropertySymbols(obj);\n    let count = keys.length + syms.length;\n\n    if (count === 0) {\n        return EMPTY_OBJECT_BYTE_CHAR;\n    }\n    if (count > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided object has too many props, limit ${MAX_7_BYTES_INTEGER}, received ${count}`);\n    }\n\n    const countBytes = integerToBytes(count);\n    const msg: string[] = [];\n\n    // type byte\n    msg.push(toChar(\n        ETypeByteCode.Object\n        | (0b0000_0111 & countBytes.length)\n    ));\n\n    // length\n    msg.push(toChar(...countBytes));\n\n    for (const key of keys) {\n        msg.push(encode(key, options));\n        msg.push(encode(obj[key], options));\n    }\n\n    for (const sym of syms) {\n        msg.push(encode(sym, options));\n        msg.push(encode(obj[sym], options));\n    }\n\n    return msg.join('');\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\nimport { toChar } from '../utils/toChar';\nimport { TPrimitiveObjectWrapper } from '../types/TPrimitiveObjectWrapper';\nimport { isPrimitiveObjectWrapper } from '../utils/vars/isPrimitiveObjectWrapper';\nimport { encode } from './encode';\n\nexport const encodePrimitiveObjectWrapper = (obj: TPrimitiveObjectWrapper, options: IEncodeOptions): string => {\n    if (!isPrimitiveObjectWrapper(obj)) {\n        throw new Error(`Expecting Promitive Object Wrapper, received \"${obj}\" (${typeof obj})`);\n    }\n\n    const msg: string[] = [];\n\n    msg.push(toChar(ETypeByteCode.Instruction & 0b1111_0000));\n    msg.push(encode(obj.valueOf(), options));\n\n    return msg.join('');\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\nimport { toChar } from '../utils/toChar';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { isInteger } from '../utils/vars/isInteger';\n\nexport const encodeRef = (mode: 'copy' | 'link', refId: number, options: IEncodeOptions): string => {\n    if (!isInteger(refId)) {\n        throw new Error(`Expecting \"integer\" type, received \"${refId}\" (${typeof refId})`);\n    }\n    if (Math.abs(refId) > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Can not encode unsafe integer`);\n    }\n\n    const msg: string[] = [];\n    const bytes = integerToBytes(refId);\n\n    // type byte\n    msg.push(toChar(\n        ETypeByteCode.Refs\n        | (mode === 'copy' ? 0b0000_1000 : 0)\n        | (0b0000_0111 & bytes.length)\n    ));\n    // encode bytes\n    msg.push(toChar(...bytes));\n\n    return msg.join('');\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\nimport { toChar } from '../utils/toChar';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { isSet } from '../utils/vars/isSet';\nimport { encode } from './encode';\n\nconst EMPTY_SET_BYTE_CHAR = toChar(ETypeByteCode.Set & 0b1111_0000);\n\nexport const encodeSet = (set: Set<any>, options: IEncodeOptions): string => {\n    if (!isSet(set)) {\n        throw new Error(`Expecting \"set\" type, received \"${set}\" (${typeof set})`);\n    }\n\n    if (set.size === 0) {\n        return EMPTY_SET_BYTE_CHAR;\n    }\n\n    if (set.size > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Provided set has too many items, limit ${MAX_7_BYTES_INTEGER}, received ${set.size}`);\n    }\n\n    const sizeBytes = integerToBytes(set.size);\n\n    const msg: string[] = [];\n    // type byte\n    msg.push(toChar(\n        ETypeByteCode.Set\n        | (0b0000_0111 & sizeBytes.length)\n    ));\n\n    // count\n    msg.push(toChar(...sizeBytes));\n\n    set.forEach((value) => {\n        msg.push(encode(value, options));\n    });\n\n    return msg.join('');\n};\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { toChar } from '../utils/toChar';\n\nconst EMPTY_STRING_BYTE_CHAR = toChar(ETypeByteCode.String & 0b1111_0000);\n\nexport const encodeString = (value: string): string => {\n    if (typeof value !== 'string') {\n        throw new Error(`Expecting \"string\" type, received \"${value}\" (${typeof value})`);\n    }\n    if (value === '') {\n        return EMPTY_STRING_BYTE_CHAR;\n    }\n    const msg: string[] = [];\n\n    const encoder = new TextEncoder();\n    const encodeBytes = encoder.encode(value);\n\n    if (encodeBytes.byteLength > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Too large string. ${encodeBytes.byteLength} bytes, limit ${MAX_7_BYTES_INTEGER}`);\n    }\n    const bytes = integerToBytes(encodeBytes.byteLength)\n    // type byte\n    msg.push(toChar(ETypeByteCode.String | (0b0000_0111 & bytes.length)));\n    // length bytes\n    msg.push(toChar(...bytes));\n    // encode bytes\n    msg.push(toChar(...encodeBytes));\n\n    return msg.join('');\n}","export const getBytesSizeForString = (str: string) => {\n    let size = 0;\n\n    for (let i = 0; i < str.length; i += 1) {\n        const chr = str[i];\n        for (let codeAt = 0; codeAt < 2; codeAt += 1) {\n            const code = chr.charCodeAt(codeAt);\n            if (isNaN(code)) {\n                continue;\n            }\n            if (code < 256) {\n                size += 1;\n            } else {\n                size += 2;\n            }\n        }\n    }\n    return size;\n}\n","import { ETypeByteCode } from '../enums/ETypeByteCode';\nimport { MAX_7_BYTES_INTEGER } from '../constants';\nimport { getBytesSizeForString } from '../converter/getBytesSizeForString';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { toChar } from '../utils/toChar';\n\nexport const encodeSymbol = (value: symbol): string => {\n    if (typeof value !== 'symbol') {\n        throw new Error(`Expecting \"symbol\" type, received \"${String(value)}\" (${typeof value})`);\n    }\n\n    const msg: string[] = [];\n\n    const key = Symbol.keyFor(value);\n\n    if (key === undefined) {\n        throw new Error(`Not found key for symbol ${String(value)}`);\n    }\n\n    const bytesCount = getBytesSizeForString(key);\n    if (bytesCount > MAX_7_BYTES_INTEGER) {\n        throw new Error(`Too large symbol key. ${bytesCount} bytes, limit ${MAX_7_BYTES_INTEGER}`);\n    }\n    const bytes = integerToBytes(bytesCount)\n    // type byte\n    msg.push(toChar(ETypeByteCode.Symbol | (0b0000_0111 & bytes.length)));\n\n    if (bytes.length) {\n        // length bytes\n        msg.push(toChar(...bytes));\n    }\n    if (key) {\n        // encode bytes\n        msg.push(key);\n    }\n\n    return msg.join('');\n}","import { TTypedArray } from '../../types/TTypedArray';\n\nexport const getFilledItemsCount = (arr: TTypedArray | ArrayBuffer): number => {\n    let count = 0;\n    const tarr = (arr instanceof ArrayBuffer) ? new Uint8Array(arr) : arr;\n    tarr.forEach((item) => {\n        if (item !== 0) {\n            count += 1\n        }\n    });\n    return count;\n}\n","import { integerToBytes } from '../../converter/integerToBytes';\nimport { TTypedArray } from '../../types/TTypedArray';\nimport { getBytesPerElement } from './getTypedArrayByteCount';\n\ninterface IResults {\n    envValueSize: number;\n    encKeyValueSize: number;\n}\n\nexport const calculateByteCountVariants = (tarr: TTypedArray | ArrayBuffer): IResults => {\n    const arr = tarr instanceof ArrayBuffer ? new Uint8Array(tarr) : tarr;\n    const bytesPerElement = getBytesPerElement(arr);\n\n    const resutls: IResults = {\n        envValueSize: arr.byteLength,\n        encKeyValueSize: 0,\n    }\n\n    for (let i = 0; i < arr.length; i += 1) {\n        const num = arr[i];\n        if (num) {\n            const bytes = integerToBytes(i);\n            resutls.encKeyValueSize +=\n                /* type */ 1\n                + /* int */ + (i > 0 ? bytes.length : 0)\n                + bytesPerElement;\n        }\n    }\n\n    return resutls;\n}","import { MAX_7_BYTES_INTEGER } from '../constants';\nimport { integerToBytes } from '../converter/integerToBytes';\nimport { IEncodeOptions } from '../types/IEncodeOptions';\nimport { TTypedArray } from '../types/TTypedArray';\nimport { toChar } from '../utils/toChar';\nimport { isTypedArray } from '../utils/vars/isTypedArray';\nimport { encodeInteger } from './encodeInteger';\nimport { getBytesPerElement } from '../utils/typedArrays/getTypedArrayByteCount';\nimport { ETypedArrayByteCode } from '../enums/ETypedArrayByteCode';\nimport { getFilledItemsCount } from '../utils/typedArrays/getFilledItemsCount';\nimport { calculateByteCountVariants } from '../utils/typedArrays/calculateByteCountVariants';\n\nconst TYPED_ARRAY_CHAR_BY_NAME = {\n    ArrayBuffer: ETypedArrayByteCode.ArrayBuffer,\n    Int8Array: ETypedArrayByteCode.Int8Array,\n    Uint8Array: ETypedArrayByteCode.Uint8Array,\n    Uint8ClampedArray: ETypedArrayByteCode.Uint8ClampedArray,\n    Int16Array: ETypedArrayByteCode.Int16Array,\n    Uint16Array: ETypedArrayByteCode.Uint16Array,\n    Int32Array: ETypedArrayByteCode.Int32Array,\n    Uint32Array: ETypedArrayByteCode.Uint32Array,\n    Float32Array: ETypedArrayByteCode.Float32Array,\n    Float64Array: ETypedArrayByteCode.Float64Array,\n    BigInt64Array: ETypedArrayByteCode.BigInt64Array,\n    BigUint64Array: ETypedArrayByteCode.BigUint64Array,\n} as const;\n\nexport const encodeTypedArray = (tarr: TTypedArray | ArrayBuffer, options?: IEncodeOptions): string => {\n    if (!isTypedArray(tarr)) {\n        throw new Error(`Expecting \"typedArray\" type, received \"${tarr}\" (${typeof tarr})`);\n    }\n\n    const name = tarr.constructor.name as keyof typeof TYPED_ARRAY_CHAR_BY_NAME;\n    const typeCode = TYPED_ARRAY_CHAR_BY_NAME[name];\n\n    if (tarr.byteLength === 0) {\n        return toChar(typeCode, 0b0000_0000);\n    }\n\n    const arr = tarr instanceof ArrayBuffer ? new Uint8Array(tarr) : tarr;\n\n    // TODO: various size\n    const bytesPerElement = getBytesPerElement(tarr);\n    const definedItemsCount = getFilledItemsCount(tarr);\n\n    if (tarr.byteLength > MAX_7_BYTES_INTEGER) {\n        throw new Error(\n            `Provided typed array has too large length, limit ${MAX_7_BYTES_INTEGER}, received ${tarr.byteLength}`\n        );\n    }\n    const msg: string[] = [];\n\n    const calculation = calculateByteCountVariants(tarr);\n    const isValueEncoding = calculation.envValueSize <= calculation.encKeyValueSize;\n\n    // type byte\n    msg.push(toChar(typeCode));\n\n    // rsv / endoding / length / items count\n    const byteLenBytes = integerToBytes(tarr.byteLength);\n    const lenBytes = integerToBytes(arr.length);\n    const defCountBytes = integerToBytes(definedItemsCount);\n    msg.push(\n        toChar(\n            0b0000_0000 |\n                (isValueEncoding ? 0 : 0b0_1_000000) |\n                (isValueEncoding ? 0 : (0b00000_111 & byteLenBytes.length) << 3) |\n                (isValueEncoding ? (0b00000_111 & lenBytes.length) : (0b00000_111 & defCountBytes.length))\n        )\n    );\n\n    if (isValueEncoding) {\n        // items count\n        msg.push(toChar(...lenBytes));\n        const uint8arr = new Uint8Array(tarr instanceof ArrayBuffer ? tarr : tarr.buffer);\n        msg.push(toChar(...uint8arr));\n    } else {\n        // length\n        msg.push(toChar(...byteLenBytes));\n        msg.push(toChar(...defCountBytes));\n        for (let i = 0; i < arr.length; i += 1) {\n            const num = arr[i];\n            if (num) {\n                const uint8arr = new Uint8Array(arr.buffer, i * bytesPerElement, bytesPerElement);\n                msg.push(encodeInteger(i));\n                msg.push(toChar(...uint8arr));\n            }\n        }\n    }\n\n    return msg.join('');\n};\n","import { EConstantByteCode } from '../enums/EConstantByteCode';\nimport { toChar } from '../utils/toChar';\n\nconst UNDEFINED_BYTE = toChar(EConstantByteCode.Undefined)\n\nexport const encodeUndefined = (): string => {\n    return UNDEFINED_BYTE;\n}","import { IEncodeOptions, IRefData } from '../types/IEncodeOptions';\nimport { isClassInstance } from '../utils/vars/isClassInstance';\nimport { isFloat } from '../utils/vars/isFloat';\nimport { isInteger } from '../utils/vars/isInteger';\nimport { isMap } from '../utils/vars/isMap';\nimport { isObject } from '../utils/vars/isObject';\nimport { isPrimitiveObjectWrapper } from '../utils/vars/isPrimitiveObjectWrapper';\nimport { isSet } from '../utils/vars/isSet';\nimport { isTypedArray } from '../utils/vars/isTypedArray';\nimport { encodeArray } from './encodeArray';\nimport { encodeBigInt } from './encodeBigInt';\nimport { encodeBoolean } from './encodeBoolean';\nimport { encodeClassInstance } from './encodeClassInstance';\nimport { encodeDate } from './encodeDate';\nimport { encodeFloat } from './encodeFloat';\nimport { encodeInfinity } from './encodeInfinity';\nimport { encodeInteger } from './encodeInteger';\nimport { encodeMap } from './encodeMap';\nimport { encodeNaN } from './encodeNaN';\nimport { encodeNull } from './encodeNull';\nimport { encodeObject } from './encodeObject';\nimport { encodePrimitiveObjectWrapper } from './encodePrimitiveObjectWrapper';\nimport { encodeRef } from './encodeRef';\nimport { encodeSet } from './encodeSet';\nimport { encodeString } from './encodeString';\nimport { encodeSymbol } from './encodeSymbol';\nimport { encodeTypedArray } from './encodeTypedArray';\nimport { encodeUndefined } from './encodeUndefined';\n\nexport const encode = (value: any, options: IEncodeOptions): string => {\n    const context = options.context;\n    const isRefEnabled = options.refs.enabled || false;\n\n    let refData: IRefData | null = null;\n    if (isRefEnabled) {\n        refData = context.refMap.get(value) || null;\n        if (refData) {\n            if (!refData.encodedRefLink) {\n                refData.encodedRefLink = encodeRef('link', refData.refId, options);\n            }\n            return refData.encodedRefLink;\n        } else {\n            const refId = context.refMap.size;\n            refData = {\n                refId: refId,\n                encodedRefLink: null,\n                encodedRefCopy: null,\n            };\n            context.refMap.set(value, refData);\n        }\n    }\n\n    let result: string | null = null;\n    let isRefAllowed: boolean = false;\n\n    const type = typeof value;\n    switch (type) {\n        case 'undefined': {\n            isRefAllowed = false;\n            result = encodeUndefined();\n            break;\n        }\n        case 'boolean': {\n            isRefAllowed = false;\n            result = encodeBoolean(value);\n            break;\n        }\n        case 'number': {\n            if (isInteger(value)) {\n                isRefAllowed = value > 255 || value < -255;\n                result = encodeInteger(value);\n                break;\n            }\n            if (isFloat(value)) {\n                isRefAllowed = true;\n                result = encodeFloat(value);\n                break;\n            }\n            if (Number.isNaN(value)) {\n                isRefAllowed = false;\n                result = encodeNaN();\n                break;\n            }\n            if (value === Infinity || value === -Infinity) {\n                isRefAllowed = false;\n                result = encodeInfinity(value);\n                break;\n            }\n            break;\n        }\n        case 'string': {\n            isRefAllowed = value.length > 2;\n            result = encodeString(value);\n            break;\n        }\n        case 'object': {\n            if (value === null) {\n                isRefAllowed = false;\n                result = encodeNull();\n                break;\n            }\n            if (Array.isArray(value)) {\n                isRefAllowed = true;\n                result = encodeArray(value, options);\n                break;\n            }\n            if (isObject(value)) {\n                isRefAllowed = true;\n                result = encodeObject(value, options);\n                break;\n            }\n            if (isSet(value)) {\n                isRefAllowed = true;\n                result = encodeSet(value, options);\n                break;\n            }\n            if (isMap(value)) {\n                isRefAllowed = true;\n                result = encodeMap(value, options);\n                break;\n            }\n            if (isTypedArray(value)) {\n                isRefAllowed = true;\n                result = encodeTypedArray(value, options);\n                break;\n            }\n            if (value instanceof Date) {\n                isRefAllowed = true;\n                result = encodeDate(value, options);\n                break;\n            }\n            if (isPrimitiveObjectWrapper(value)) {\n                isRefAllowed = true;\n                result = encodePrimitiveObjectWrapper(value, options);\n                break;\n            }\n            if (isClassInstance(value)) {\n                isRefAllowed = true;\n                result = encodeClassInstance(value, options);\n                break;\n            }\n            break;\n        }\n        case 'bigint': {\n            isRefAllowed = true;\n            result = encodeBigInt(value);\n            break;\n        }\n        case 'symbol': {\n            isRefAllowed = true;\n            result = encodeSymbol(value);\n            break;\n        }\n    }\n\n    if (result === null) {\n        throw new Error(`Unsupported encoding value: \"${value}\", type: \"${type}\"`);\n    }\n\n    if (refData) {\n        if (isRefAllowed) {\n            const refCopy = context.refCopy.get(result);\n            if (refCopy) {\n                if (!refData.encodedRefCopy) {\n                    refData.encodedRefCopy = encodeRef('copy', refCopy.refId, options);\n                }\n                return refData.encodedRefCopy;\n            } else {\n                context.refCopy.set(result, refData);\n            }\n        } else {\n            context.refMap.delete(value);\n        }\n    }\n\n    return result;\n};\n","import { IEncodeOptions } from '../../types/IEncodeOptions';\n\nexport const createEncodeOptions = (): IEncodeOptions => {\n    return {\n        refs: {\n            enabled: false\n        },\n        context: {\n            refMap: new Map(),\n            refCopy: new Map(),\n        },\n        objects: {\n            classInstanceConstructorNameKey: '__jsbtConstructorName',\n        }\n    }\n}","import { decode } from './decoder/decode';\nimport { decodeStream } from './decoder/decodeStream';\nimport { createDecodeOptions } from './decoder/options/createDecodeOptions';\nimport { encode } from './encoder/encode';\nimport { createEncodeOptions } from './encoder/options/createEncodeOptions';\nimport ByteStream from './reader/ByteStream';\nimport { TDecodeClassConstructor } from './types/IDecodeOptions';\n\nexport class JSBT {\n\n    protected static _classFactories: Record<string, TDecodeClassConstructor<object>> = {};\n\n    static setClassFactories(factories: Record<string, TDecodeClassConstructor<object>>): void {\n        this._classFactories = factories;\n    }\n\n    static encode(value: any): string {\n        const options = createEncodeOptions();\n        options.refs.enabled = true;\n        const result = encode(value, options);\n        return result;\n    }\n\n    static decode<T = any>(value: string | string[] | number[]): T {\n        const stream = new ByteStream(value);\n        stream.completeStream();\n        const options = createDecodeOptions();\n        options.objects.factories = this._classFactories;\n        options.context.readBytes = stream.getReadBytes();\n        const result = decode(null, stream, options) as T;\n        return result;\n    }\n\n    static async decodeStream<T = any>(stream: ByteStream): Promise<T> {\n        const options = createDecodeOptions();\n        options.objects.factories = this._classFactories;\n        options.context.readBytes = stream.getReadBytes();\n        const result = decodeStream(null, stream, options) as Promise<T>;\n        return result;\n    }\n\n}\n"],"mappings":"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","names":["ByteStream","msg","timeout","promise","resolve","reject","count","bytes","bytesLen","charCode","block","bytesToInteger","bytes","len","int","i","EConstantByteCode","decodeInteger","typeByte","stream","count","isNegative","bytesCount","int","bytesToInteger","decodeArray","typeByte","stream","options","initArr","isKeyValueEncoding","bytesCount","arrayLen","bytesToInteger","itemsCoint","arr","i","key","decodeInteger","value","decode","byte","EConstantByteCode","bytesToBigInt","bytes","len","bint","i","decodeBigInt","typeByte","stream","count","isNegative","bytesCount","encodeCount","bytesToInteger","encodeBytes","bint","bytesToBigInt","constantMap","EConstantByteCode","decodeConstant","typeByte","stream","decodeDate","typeByte","stream","count","isNegative","bytesCount","int","bytesToInteger","decodeFloat","typeByte","stream","count","map","i","bytesCount","floatBytes","byteIndex","decodeMap","typeByte","stream","options","initMap","bytesCount","count","bytesToInteger","map","i","key","decode","value","decodeObject","typeByte","stream","options","initObj","bytesCount","count","bytesToInteger","isClassInstance","constructorName","decode","obj","i","key","value","constructorNameKey","classConstructor","decodePrimitiveObjectWrapper","typeByte","stream","options","value","decode","createDecodeOptions","decodeRef","typeByte","stream","options","isCopy","count","id","bytesToInteger","refs","refSlice","slice","decOptions","createDecodeOptions","st","ByteStream","decode","decodeSet","typeByte","stream","options","initSet","bytesCount","count","bytesToInteger","set","i","value","decode","decodeString","typeByte","stream","count","bytesCount","bytesLength","bytesToInteger","decoder","bytes","bytesToUtf16","bytes","msg","len","i","currentByte","nextByte","decodeSymbol","typeByte","stream","count","bytesCount","strLen","bytesToInteger","bytes","bytesToUtf16","ETypedArrayByteCode","getBytesPerElement","arr","typedArrayConstructorByType","ETypedArrayByteCode","dataViewGetter","decodeTypedArray","typeByte","stream","options","secondByte","isKeyValueEncoding","itemsBytesCount","lengthBytesCount","TypedArrayConstructor","tarr0","bytesPerElement","getBytesPerElement","len","bytesToInteger","count","dataGetterName","tarr","i","key","decodeInteger","valueBytes","view","decode","typeByte","stream","options","refs","refByteSlice","type","isRefEnabled","refId","isRefAllowed","result","isResultReceived","decodeRef","decodeConstant","decodeString","decodeInteger","decodeFloat","decodeBigInt","decodeArray","decodeTypedArray","decodeObject","decodeSet","decodeMap","decodeSymbol","decodeDate","decodePrimitiveObjectWrapper","decodeIntegerStream","typeByte","stream","count","isNegative","bytesCount","int","bytesToInteger","decodeArrayStream","typeByte","stream","options","initArr","isKeyValueEncoding","bytesCount","arrayLen","bytesToInteger","itemsCoint","arr","i","key","decodeIntegerStream","value","decodeStream","byte","EConstantByteCode","decodeBigIntStream","typeByte","stream","count","isNegative","bytesCount","encodeCount","bytesToInteger","encodeBytes","bint","bytesToBigInt","decodeConstantStream","typeByte","stream","constantMap","decodeDateStream","typeByte","stream","count","isNegative","bytesCount","int","bytesToInteger","decodeFloatStream","typeByte","stream","count","map","i","bytesCount","floatBytes","byteIndex","decodeMapStream","typeByte","stream","options","initMap","bytesCount","count","bytesToInteger","map","i","key","decodeStream","value","decodeObjectStream","typeByte","stream","options","initObj","bytesCount","count","bytesToInteger","isClassInstance","constructorName","decodeStream","obj","i","key","value","constructorNameKey","classConstructor","decodePrimitiveObjectWrapperStream","typeByte","stream","options","value","decodeStream","decodeRefStream","typeByte","stream","options","isCopy","count","id","bytesToInteger","refs","refSlice","slice","decOptions","createDecodeOptions","st","ByteStream","decode","decodeSetStream","typeByte","stream","options","initSet","bytesCount","count","bytesToInteger","set","i","value","decodeStream","decodeStringStream","typeByte","stream","count","bytesCount","bytesLength","bytesToInteger","decoder","bytes","decodeSymbolStream","typeByte","stream","count","bytesCount","strLen","bytesToInteger","bytes","bytesToUtf16","decodeTypedArrayStream","typeByte","stream","options","secondByte","isKeyValueEncoding","itemsBytesCount","lengthBytesCount","TypedArrayConstructor","typedArrayConstructorByType","tarr0","bytesPerElement","getBytesPerElement","len","bytesToInteger","count","dataGetterName","dataViewGetter","tarr","i","key","decodeIntegerStream","valueBytes","view","ETypedArrayByteCode","decodeStream","typeByte","stream","options","refs","refByteSlice","type","isRefEnabled","refId","isRefAllowed","result","isResultReceived","decodeRefStream","decodeConstantStream","decodeStringStream","decodeIntegerStream","decodeFloatStream","decodeBigIntStream","decodeArrayStream","decodeTypedArrayStream","decodeObjectStream","decodeSetStream","decodeMapStream","decodeSymbolStream","decodeDateStream","decodePrimitiveObjectWrapperStream","isClassInstance","value","isFloat","value","isInteger","value","isMap","value","isObject","value","isPrimitiveObjectWrapper","value","isSet","value","isTypedArray","value","integerToBytes","num","byteSize","bytes","n","count","getFilledItemsCount","arr","count","toChar","codes","EMPTY_VALUE_BYTE_CHR","toChar","EConstantByteCode","encodeEmptyValue","POS_ZERO_BYTE_CHAR","toChar","NEG_ZERO_BYTE_CHAR","encodeInteger","value","isInteger","msg","val","isPositive","bytes","integerToBytes","EMPTY_ARRAY_BYTE_CHAR","toChar","SPARSE_RATE","encodeArray","arr","options","filledCount","getFilledItemsCount","isSparseEncoding","bytes","integerToBytes","msg","countBytes","item","index","encodeInteger","encode","i","isEmptyValue","encodeEmptyValue","bigIntToBytes","bint","byteSize","bigEndianOrder","bytes","num","isBigInt","value","ZERO_BYTE_CHAR","toChar","encodeBigInt","value","isBigInt","val","isPositive","msg","bytes","bigIntToBytes","lenBytes","integerToBytes","i","TRUE_BYTE_CHR","toChar","EConstantByteCode","FALSE_BYTE_CHR","encodeBoolean","value","encodeClassInstance","obj","options","isClassInstance","props","msgBody","count","constructorNameKey","constructorName","encode","key","sym","msgHeaders","countBytes","integerToBytes","toChar","ZERO_BYTE_CHAR","toChar","encodeDate","value","options","ms","msg","val","isPositive","bytes","integerToBytes","_buffer","_float64","_uint8","doubleToBytes","value","bigEndianOrder","encodeFloat","value","mapping","isFloat","bytes","doubleToBytes","startTrim","trimmedLen","byteMap","mappedCount","i","isMapping","payloadLen","msg","toChar","out","j","b","POS_INFINITY_CHR","toChar","EConstantByteCode","NEG_INFINITY_CHR","encodeInfinity","value","EMPTY_MAP_BYTE_CHAR","toChar","encodeMap","map","options","isMap","sizeBytes","integerToBytes","msg","value","key","encode","NAN_BYTE","toChar","EConstantByteCode","encodeNaN","NULL_BYTE","toChar","EConstantByteCode","encodeNull","EMPTY_OBJECT_BYTE_CHAR","toChar","encodeObject","obj","options","isObject","keys","syms","count","countBytes","integerToBytes","msg","key","encode","sym","encodePrimitiveObjectWrapper","obj","options","isPrimitiveObjectWrapper","msg","toChar","encode","encodeRef","mode","refId","options","isInteger","msg","bytes","integerToBytes","toChar","EMPTY_SET_BYTE_CHAR","toChar","encodeSet","set","options","isSet","sizeBytes","integerToBytes","msg","value","encode","EMPTY_STRING_BYTE_CHAR","toChar","encodeString","value","msg","encodeBytes","bytes","integerToBytes","getBytesSizeForString","str","size","i","chr","codeAt","code","encodeSymbol","value","msg","key","bytesCount","getBytesSizeForString","bytes","integerToBytes","toChar","getFilledItemsCount","arr","count","item","calculateByteCountVariants","tarr","arr","bytesPerElement","getBytesPerElement","resutls","i","bytes","integerToBytes","TYPED_ARRAY_CHAR_BY_NAME","ETypedArrayByteCode","encodeTypedArray","tarr","options","isTypedArray","name","typeCode","toChar","arr","bytesPerElement","getBytesPerElement","definedItemsCount","getFilledItemsCount","msg","calculation","calculateByteCountVariants","isValueEncoding","byteLenBytes","integerToBytes","lenBytes","defCountBytes","uint8arr","i","encodeInteger","UNDEFINED_BYTE","toChar","EConstantByteCode","encodeUndefined","encode","value","options","context","isRefEnabled","refData","encodeRef","result","isRefAllowed","type","encodeUndefined","encodeBoolean","isInteger","encodeInteger","isFloat","encodeFloat","encodeNaN","encodeInfinity","encodeString","encodeNull","encodeArray","isObject","encodeObject","isSet","encodeSet","isMap","encodeMap","isTypedArray","encodeTypedArray","encodeDate","isPrimitiveObjectWrapper","encodePrimitiveObjectWrapper","isClassInstance","encodeClassInstance","encodeBigInt","encodeSymbol","refCopy","createEncodeOptions","JSBT","factories","value","options","createEncodeOptions","encode","stream","ByteStream","createDecodeOptions","decode","decodeStream"]}